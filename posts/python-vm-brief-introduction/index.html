<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=stylesheet type=text/css href=/css/bootstrap.min.css><link rel=stylesheet type=text/css href=/css/style.css><title>Superjomn's blog | Python VM 执行方式简要探索</title></head><body><div id=nav-border class=container><nav id=nav class="nav justify-content-center"><a class=nav-link href=/posts/><i data-feather=home></i>
Home</a>
<a class=nav-link href=/posts/><i data-feather=pen-tool></i>
Posts</a>
<a class=nav-link href=/tags/><i data-feather=tag></i>
Tags</a>
<a class=nav-link href=/posts/about/><i data-feather=info></i>
About</a></nav></div><div class=container><main id=main><h1>Python VM 执行方式简要探索</h1><i data-feather=calendar></i> <time datetime=2023-02-24>Feb 24, 2023</time>
<span id=social></span><i data-feather=tag></i>
<a class="btn btn-sm btn-outline-dark tag-btn" href=tags/python>python</a><br><br><ul><li><a href=#python-code-object>Python Code Object</a><ul><li><a href=#%E6%9C%89%E7%94%A8%E7%9A%84-attribute>有用的 attribute</a></li><li><a href=#python-bytecode-%E7%90%86%E8%A7%A3>Python Bytecode 理解</a></li></ul></li><li><a href=#python-frame>Python Frame</a><ul><li><a href=#%E4%BF%AE%E6%94%B9-frame-%E7%9A%84-code-object>修改 Frame 的 Code Object</a></li></ul></li><li><a href=#%E6%80%BB%E7%BB%93>总结</a></li><li><a href=#fyi>FYI</a></li></ul><p>最近在看 TorchDynamo 的东西，里面需要对 Python 执行机制有一些了解，所以单独拆开放到了这篇文章里。</p><p>本文会从可复现的角度，多一些可以执行的例子。</p><h2 id=python-code-object>Python Code Object</h2><p>这里是简单的介绍，详细的可以参考 <a href=https://leanpub.com/insidethepythonvirtualmachine/read#leanpub-auto-code-objects>code objects</a> 这本书的章节。</p><p>Code object 用来记录 Python 的 byte code，对应的粒度是 Block，这里的 Block 可以包含从 Module 到 Class definition 到 Function body 的各类结构（有别于编译器里面的 BasicBlock）。 可以理解 Code object 是可以嵌套的。</p><p>我们先从一个简单的函数开始</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(name, age):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;&#39;&#39; Get the information of a person. &#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>    born <span style=color:#f92672>=</span> <span style=color:#ae81ff>2023</span> <span style=color:#f92672>-</span> age
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;hello </span><span style=color:#e6db74>{</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>, born at </span><span style=color:#e6db74>{</span>born<span style=color:#e6db74>}</span><span style=color:#e6db74>!&#34;</span>
</span></span></code></pre></div><p>查看其 Code object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>foo<span style=color:#f92672>.</span>__code__
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&lt;code object foo at 0x7f4da6f59500, file &#34;/tmp/ipykernel_2935902/3583013317.py&#34;, line 1&gt;
</span></span></code></pre></div><h3 id=有用的-attribute>有用的 attribute</h3><p>那 <code>foo.__code__</code> 中包含的有用的 attribute 如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>dir(foo<span style=color:#f92672>.</span>__code__)
</span></span></code></pre></div><p>得到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>[<span style=color:#e6db74>&#39;__class__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__delattr__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__dir__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__doc__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__eq__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__format__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__ge__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__getattribute__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__gt__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__hash__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__init__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__init_subclass__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__le__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__lt__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__ne__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__new__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__reduce__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__reduce_ex__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__repr__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__setattr__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__sizeof__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__str__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;__subclasshook__&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;co_argcount&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;co_cellvars&#39;</span>,
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;co_nlocals&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;co_posonlyargcount&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;co_stacksize&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;co_varnames&#39;</span>,
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#39;replace&#39;</span>]
</span></span></code></pre></div><p>其中比较多打交道的属性如下</p><ul><li><strong><code>co_names</code></strong> is a tuple containing global attributes and methods used inside the scope,</li><li><strong><code>co_varname</code></strong> is the tuple containing local variable names used in function,</li><li><strong><code>co_consts</code></strong> returns the literals used by bytecode.</li></ul><p>对应属性的内容如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>call_foo<span style=color:#f92672>.</span>__code__<span style=color:#f92672>.</span>co_names
</span></span></code></pre></div><p><code>co_names</code> 是空的，因为 <code>foo</code> 函数里面没有调用任何的外部函数或属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>foo<span style=color:#f92672>.</span>__code__<span style=color:#f92672>.</span>co_varnames
</span></span></code></pre></div><p><code>co_varnames</code> 比较丰富，看到 local scope 可以用的 variable name 都在里面，包括两个 argument： name 和 age，以及一个 local variable： born。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>foo<span style=color:#f92672>.</span>__code__<span style=color:#f92672>.</span>co_consts
</span></span></code></pre></div><p><code>co_consts</code> 意料外有好几个，一类是 code 里面用到的 <strong>2023</strong> 这个常量，另外几个字符串是 string format 里面分割开的几个字段。</p><h3 id=python-bytecode-理解>Python Bytecode 理解</h3><p>接下来我们尝试理解下简单的 Python bytecode，接着上面的例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>dis<span style=color:#f92672>.</span>dis(foo)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> 2           0 LOAD_CONST               1 (2023)
</span></span><span style=display:flex><span>             2 LOAD_FAST                1 (age)
</span></span><span style=display:flex><span>             4 BINARY_SUBTRACT
</span></span><span style=display:flex><span>             6 STORE_FAST               2 (born)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 3           8 LOAD_CONST               2 (&#39;hello &#39;)
</span></span><span style=display:flex><span>            10 LOAD_FAST                0 (name)
</span></span><span style=display:flex><span>            12 FORMAT_VALUE             0
</span></span><span style=display:flex><span>            14 LOAD_CONST               3 (&#39;, born at &#39;)
</span></span><span style=display:flex><span>            16 LOAD_FAST                2 (born)
</span></span><span style=display:flex><span>            18 FORMAT_VALUE             0
</span></span><span style=display:flex><span>            20 LOAD_CONST               4 (&#39;!&#39;)
</span></span><span style=display:flex><span>            22 BUILD_STRING             5
</span></span><span style=display:flex><span>            24 RETURN_VALUE
</span></span></code></pre></div><p>上面 dump 出来的内容包含了 <code>dis</code> 增加的一些 human readable 的 hint，具体内容可以分为 3 列：</p><ol><li>表示原始 Python 源代码中的行号</li><li>bytecode 中的行号以及对应的 opcode</li><li>argument ID，圆括弧里面是一些 hint</li></ol><p>这里需要提一下， Python 的执行方式是基于 Stack 而非 Register，带来的好处就是 bytecode 逻辑非常简单，常见的操作如下</p><ul><li>在执行一个 Opcode 前，将其所需的 variable 压栈</li><li>执行这个 Opcode 时，从 stack 中 Pop 所需数目的 variable</li><li>将执行结果压入 stack 中，备后续使用</li></ul><p>上面的前三行 code</p><pre tabindex=0><code class=language-nil data-lang=nil>2           0 LOAD_CONST               1 (2023)
            2 LOAD_FAST                1 (age)
            4 BINARY_SUBTRACT
</code></pre><p>表示的是</p><ol><li>将 1st 常量 2023 压栈</li><li>将 1st 变量 age 压栈</li><li>Pop 两个值，并执行 2023 - age</li><li>将结果压栈</li></ol><p>Opcode 有一些具体的含义，比如其中几个比较重要的</p><ul><li><code>LOAD_CONST</code> 表示是从 Code object 的 <code>co_consts</code> 里面 load<ul><li>参考上节，~co_consts~ 第 1 个 value 是 2023， 因此 <code>LOAD_CONST 1</code> 表示 Load 2023 进 stack，跟末尾的 hint 对应起来了</li></ul></li><li><code>LOAD_FAST</code> 是从 <code>co_varnames</code> 里面 Load 到 stack</li><li><code>STORE_FAST</code> 表示将 stack 的 head 中的值 Store 到 <code>co_varnames</code> 里面的一个 variable</li><li><code>RETURN_VALUE</code> 表示将 stack 中包含的所有值返回</li></ul><p>完整的 opcode 及对应的 Python 的处理行为可以参考 <a href=https://github.com/python/cpython/blob/22b8d77b98a5944e688be0927b8139c49d4a7257/Python/generated_cases.c.h>Python/generated_cases.c.h</a>，内容非常清晰，截取 <code>LOAD_FAST</code> 对应的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>TARGET(LOAD_FAST) {
</span></span><span style=display:flex><span>            PyObject <span style=color:#f92672>*</span>value;
</span></span><span style=display:flex><span>            value <span style=color:#f92672>=</span> GETLOCAL(oparg);
</span></span><span style=display:flex><span>            assert(value <span style=color:#f92672>!=</span> NULL);
</span></span><span style=display:flex><span>            Py_INCREF(value);
</span></span><span style=display:flex><span>            STACK_GROW(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            POKE(<span style=color:#ae81ff>1</span>, value);
</span></span><span style=display:flex><span>            DISPATCH();
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><h2 id=python-frame>Python Frame</h2><p>Python Code Object 存储了待执行的 Python bytecode，但这些 bytecode 无法直接执行，还需要专门的 Interpreter 机制。
这跟 C/C++ 完全不同，毕竟 bytecode 和 machine code 完全是两码事。</p><p>为了执行 bytecode， Python 对应有 Frame Object 的数据结构，简单可以认为 Frame Object 跟 Code Object 对应，前者 hold 执行一个 Code Object 所需要的所有 runtime 的信息，而后者则记录了具体需要执行的 bytecode。
因此，当从一个 Block 跳到另外一个 Block 时候，会有 Frame 的切换，例如，function call 时，会先 hold 住当前的 Frame，创建一个新的 Frame 接着执行该 function 对应的 Code Object； 执行完毕，则跳回先前的 Frame。</p><p>Frame 具体数据结构我们需要参考下 <a href=https://github.com/python/cpython/blob/main/Include/internal/pycore_frame.h#L16>pycore_frame.h/_frame</a> 相关的 code：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_frame</span> {
</span></span><span style=display:flex><span>    PyObject_HEAD
</span></span><span style=display:flex><span>    PyFrameObject <span style=color:#f92672>*</span>f_back;      <span style=color:#75715e>/* previous frame, or NULL */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_PyInterpreterFrame</span> <span style=color:#f92672>*</span>f_frame; <span style=color:#75715e>/* points to the frame data */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_trace;          <span style=color:#75715e>/* Trace function */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> f_lineno;               <span style=color:#75715e>/* Current line number. Only valid if non-zero */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> f_trace_lines;         <span style=color:#75715e>/* Emit per-line trace events? */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> f_trace_opcodes;       <span style=color:#75715e>/* Emit per-opcode trace events? */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> f_fast_as_locals;      <span style=color:#75715e>/* Have the fast locals of this frame been converted to a dict? */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* The frame data, if this frame object owns the frame */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>_f_frame_data[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>其中 <code>f_back</code> 指针用来 chain 多个跳转的 Frame，这样上面的 function call 才可以实施。</p><p><code>f_frame</code> 记录了一个 Frame 具体的信息，接着看下如下 code</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_PyInterpreterFrame</span> {
</span></span><span style=display:flex><span>    PyCodeObject <span style=color:#f92672>*</span>f_code; <span style=color:#75715e>/* Strong reference */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>_PyInterpreterFrame</span> <span style=color:#f92672>*</span>previous;
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_funcobj; <span style=color:#75715e>/* Strong reference. Only valid if not on C stack */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_globals; <span style=color:#75715e>/* Borrowed reference. Only valid if not on C stack */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_builtins; <span style=color:#75715e>/* Borrowed reference. Only valid if not on C stack */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>f_locals; <span style=color:#75715e>/* Strong reference, may be NULL. Only valid if not on C stack */</span>
</span></span><span style=display:flex><span>    PyFrameObject <span style=color:#f92672>*</span>frame_obj; <span style=color:#75715e>/* Strong reference, may be NULL. Only valid if not on C stack */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// NOTE: This is not necessarily the last instruction started in the given
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// frame. Rather, it is the code unit *prior to* the *next* instruction. For
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// example, it may be an inline CACHE entry, an instruction we just jumped
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// over, or (in the case of a newly-created frame) a totally invalid value:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _Py_CODEUNIT <span style=color:#f92672>*</span>prev_instr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> stacktop;  <span style=color:#75715e>/* Offset of TOS from localsplus  */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> yield_offset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> owner;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Locals and stack */</span>
</span></span><span style=display:flex><span>    PyObject <span style=color:#f92672>*</span>localsplus[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>} _PyInterpreterFrame;
</span></span></code></pre></div><p>这里比较明确的是</p><ul><li><code>f_code</code> 肯定是指向对应的 Code Object</li><li><code>f_globals</code>, <code>f_locals</code> 应该直接对应到 Code Object 里面的 <code>co_names</code> 和 <code>co_varnames</code></li><li><code>stacktop</code> 对应着 stack 中的 top 位置</li></ul><h3 id=修改-frame-的-code-object>修改 Frame 的 Code Object</h3><p>得益于 <a href=https://peps.python.org/pep-0523/>PEP 523</a>，从 Python 3.6 开始，一个 <code>PyEval_EvalFrameEx()</code> 函数加入了 Python API，不同于之前的 <code>PyEval_EvalFrameDefault()</code> ， 新函数允许用户自定义 Frame Object 执行过程。</p><p>类似 TorchDynamo，与 Python 交互最核心的也是通过这个 API。</p><p>API 的实现很简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>PyObject <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>PyEval_EvalFrameEx</span>(PyFrameObject <span style=color:#f92672>*</span>frame, <span style=color:#66d9ef>int</span> throwflag)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    PyThreadState <span style=color:#f92672>*</span>tstate <span style=color:#f92672>=</span> PyThreadState_GET();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> tstate<span style=color:#f92672>-&gt;</span>interp<span style=color:#f92672>-&gt;</span>eval_frame(frame, throwflag);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只要用户设置了自定义的 interpreter，那就执行自定义的 <code>eval_frame</code> 逻辑，这一点也是 TorchDynamo 的核心。</p><h2 id=总结>总结</h2><p>本文主要介绍了 Python 执行机制中 Code Object 和 Frame Object 两个重要的概念，具体特点如下</p><ul><li>Code Object 和 Frame Object 对应到 Block 粒度</li><li>Code Object 主要记录了 bytecode 以及 <code>co_names</code>, <code>co_varnames</code> 等一大类静态信息</li><li>Frame Object 跟 Code Object 基本一一对应，记录了执行所需的信息，当出现类似 function call，新的 Frame Object 会创建接着执行，完毕后再返回当前 Frame</li></ul><h2 id=fyi>FYI</h2><ul><li><a href=https://leanpub.com/insidethepythonvirtualmachine/read#leanpub-auto-code-objects>Inside the Python Virtual Machine</a> ，一本详细讲解 Python VM 的书</li><li><a href=https://tenthousandmeters.com/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/>Python behind the scenes #1: how the CPython VM works</a></li></ul><p class="footer text-center">Copyright (c) 2023 Chunwei Yan</p></main></div><script src=/js/feather.min.js></script>
<script>feather.replace()</script></body></html>