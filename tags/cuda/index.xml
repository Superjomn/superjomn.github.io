<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cuda on Superjomn's blog</title><link>/tags/cuda/</link><description>Recent content in Cuda on Superjomn's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 12 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="/tags/cuda/index.xml" rel="self" type="application/rss+xml"/><item><title>Elementwise Add Kernel in CUDA</title><link>/posts/element-add-kernel-in-cuda-org-executor.executed/</link><pubDate>Tue, 12 Aug 2025 00:00:00 +0000</pubDate><guid>/posts/element-add-kernel-in-cuda-org-executor.executed/</guid><description>&lt;p>In this post, I will walk through the reduce kernels in &lt;a href="https://github.com/xlite-dev/LeetCUDA/tree/main/kernels">LeetCUDA&lt;/a> and implement them interactively in this file using org-executor.&lt;/p>
&lt;h2 id="background">Background&lt;/h2>
&lt;p>In CUDA programming, an elementwise kernel is a fundamental building block that applies a given operation independently to each element of an input array (or arrays), producing an output array of the same shape. This is highly parallelizable, as each thread can process a single element without dependencies on others.&lt;/p>
&lt;p>Elementwise kernels are commonly used for operations such as vector addition, scaling, activation functions in neural networks, and more. Understanding how to implement an efficient elementwise kernel is essential before moving on to more complex patterns like reductions.&lt;/p>
&lt;p>In the following sections, we will review how to write a basic elementwise kernel in CUDA, discuss its memory access patterns, and explore best practices for maximizing performance.&lt;/p>
&lt;h2 id="environment-setting">Environment setting&lt;/h2>
&lt;p>Just follow the LeetCUDA&amp;rsquo;s settings, we will expose all the kernels to PyTorch and use its facilities to do performance and precession evaluation.&lt;/p>
&lt;h3 id="pytorch">PyTorch&lt;/h3>
&lt;p>The python version:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">torch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(torch&lt;span style="color:#666">.&lt;/span>__version__)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2.8.0a0+5228986c39.nv25.06&lt;/p>
&lt;h3 id="hardware">Hardware&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span> NVIDIA H100 80GB HBM3, 81559 MiB, 81080 MiB, 0 MiB, 575.57.08, 23, 0 %
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kernel-launching-utils">Kernel Launching Utils&lt;/h3>
&lt;p>Common C++ header content:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#pragma once
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;cuda_bf16.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;cuda_fp16.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;cuda_fp8.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;cuda_runtime.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;float.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;torch/extension.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;torch/types.h&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>There are some common code for launching kernel with torch facilities.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define CEIL(x, y) (((x) + (y) - 1) / (y))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define WARP_SIZE 32
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define INT4(value) (reinterpret_cast&amp;lt;int4*&amp;gt;(&amp;amp;(value))[0])
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define FLOAT4(value) (reinterpret_cast&amp;lt;float4*&amp;gt;(&amp;amp;(value))[0])
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define FLOAT4(value) (reinterpret_cast&amp;lt;float4*&amp;gt;(&amp;amp;(value))[0])
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define HALF2(value) (reinterpret_cast&amp;lt;half2*&amp;gt;(&amp;amp;(value))[0])
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define BFLOAT2(value) (reinterpret_cast&amp;lt;__nv_bfloat162*&amp;gt;(&amp;amp;(value))[0])
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define LDST128BITS(value) (reinterpret_cast&amp;lt;float4*&amp;gt;(&amp;amp;(value))[0])
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">inline&lt;/span> &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">check_torch_dtype&lt;/span>(torch&lt;span style="color:#666">::&lt;/span>Tensor tensor,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> torch&lt;span style="color:#666">::&lt;/span>ScalarType expected_dtype) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (tensor.dtype() &lt;span style="color:#666">!=&lt;/span> expected_dtype) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">throw&lt;/span> std&lt;span style="color:#666">::&lt;/span>runtime_error(&lt;span style="color:#4070a0">&amp;#34;Tensor dtype mismatch&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">inline&lt;/span> std&lt;span style="color:#666">::&lt;/span>tuple&lt;span style="color:#666">&amp;lt;&lt;/span>dim3, dim3&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>get_launch_dimensions(&lt;span style="color:#902000">int&lt;/span> N, &lt;span style="color:#902000">int&lt;/span> elements_per_block &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">256&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> element_per_thread &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> &lt;span style="color:#902000">int&lt;/span> threads_per_block &lt;span style="color:#666">=&lt;/span> elements_per_block &lt;span style="color:#666">/&lt;/span> element_per_thread;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dim3 &lt;span style="color:#06287e">block_size&lt;/span>(threads_per_block);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dim3 &lt;span style="color:#06287e">grid_size&lt;/span>(CEIL(N, elements_per_block));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> {grid_size, block_size};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define TORCH_BINDING_COMMON_EXTENSION(func) m.def(#func, &amp;amp;func, #func);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define TORCH_BINDING_ELEM_ADD(packed_type, th_type, element_type, \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> elements_per_thread) \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> __global__ void elementwise_add_##packed_type##_kernel( \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> element_type* __restrict__ a, \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> element_type* __restrict__ b, \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> element_type* __restrict__ c, int N); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> void elementwise_add_##packed_type(torch::Tensor A, torch::Tensor B, \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> torch::Tensor C, \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> int elements_per_block) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> check_torch_dtype(A, th_type); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> check_torch_dtype(B, th_type); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> check_torch_dtype(C, th_type); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> auto [grid, block] = get_launch_dimensions(A.numel(), elements_per_block, \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> elements_per_thread); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> elementwise_add_##packed_type##_kernel&amp;lt;&amp;lt;&amp;lt;grid, block&amp;gt;&amp;gt;&amp;gt;( \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> reinterpret_cast&amp;lt;element_type*&amp;gt;(A.data_ptr()), \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> reinterpret_cast&amp;lt;element_type*&amp;gt;(B.data_ptr()), \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> reinterpret_cast&amp;lt;element_type*&amp;gt;(C.data_ptr()), A.numel()); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020"> }
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="kernels">Kernels&lt;/h2>
&lt;h3 id="basic-kernel">Basic kernel&lt;/h3>
&lt;p>This kernel demonstrates a basic elementwise addition operation in CUDA, where each thread adds two corresponding elements from the input arrays:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;#34;elementwise_add.cuh&amp;#34;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">elementwise_add_f32_kernel&lt;/span>(&lt;span style="color:#902000">float&lt;/span>&lt;span style="color:#666">*&lt;/span> __restrict__ a,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">float&lt;/span>&lt;span style="color:#666">*&lt;/span> __restrict__ b,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">float&lt;/span>&lt;span style="color:#666">*&lt;/span> __restrict__ c, &lt;span style="color:#902000">int&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> tid &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (tid &lt;span style="color:#666">&amp;lt;&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c[tid] &lt;span style="color:#666">=&lt;/span> a[tid] &lt;span style="color:#666">+&lt;/span> b[tid];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="explain">Explain&lt;/h4>
&lt;p>Each thread loads one float (4 bytes) independently, this should result in poor memory coalescing.&lt;/p>
&lt;h3 id="floatx4-vector-load">floatx4 vector load&lt;/h3>
&lt;p>This kernel introduces vectorized load and store operations using `float4`, which allows each thread to process four floats at once. By loading 16 bytes (128 bits) per memory transaction instead of 4 bytes, this approach significantly improves memory bandwidth utilization and coalescing efficiency. Each thread processes 4 elements simultaneously, reducing the total number of memory transactions by 4x compared to the basic kernel:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;#34;elementwise_add.cuh&amp;#34;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">elementwise_add_f32x4_kernel&lt;/span>(&lt;span style="color:#902000">float&lt;/span>&lt;span style="color:#666">*&lt;/span> __restrict__ a,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">float&lt;/span>&lt;span style="color:#666">*&lt;/span> __restrict__ b,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">float&lt;/span>&lt;span style="color:#666">*&lt;/span> __restrict__ c, &lt;span style="color:#902000">int&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> idx &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">4&lt;/span> &lt;span style="color:#666">*&lt;/span> (blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (idx &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">3&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> float4 reg_a &lt;span style="color:#666">=&lt;/span> FLOAT4(a[idx]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> float4 reg_b &lt;span style="color:#666">=&lt;/span> FLOAT4(b[idx]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> float4 reg_c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reg_c.x &lt;span style="color:#666">=&lt;/span> reg_a.x &lt;span style="color:#666">+&lt;/span> reg_b.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reg_c.y &lt;span style="color:#666">=&lt;/span> reg_a.y &lt;span style="color:#666">+&lt;/span> reg_b.y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reg_c.z &lt;span style="color:#666">=&lt;/span> reg_a.z &lt;span style="color:#666">+&lt;/span> reg_b.z;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reg_c.w &lt;span style="color:#666">=&lt;/span> reg_a.w &lt;span style="color:#666">+&lt;/span> reg_b.w;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FLOAT4(c[idx]) &lt;span style="color:#666">=&lt;/span> reg_c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="fp16x2-kernel">fp16x2 kernel&lt;/h3>
&lt;p>This kernel leverages half-precision (fp16) data types with vectorized operations using `half2`. Each thread processes 2 half-precision values simultaneously using CUDA&amp;rsquo;s native half2 intrinsics. This provides both memory bandwidth improvements (loading 4 bytes per transaction) and computational efficiency through packed arithmetic operations:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;#34;elementwise_add.cuh&amp;#34;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">elementwise_add_f16x2_kernel&lt;/span>(half&lt;span style="color:#666">*&lt;/span> __restrict__ a, half&lt;span style="color:#666">*&lt;/span> __restrict__ b, half&lt;span style="color:#666">*&lt;/span> __restrict__ c, &lt;span style="color:#902000">int&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> idx &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">*&lt;/span> (blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (idx &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> half2 reg_a &lt;span style="color:#666">=&lt;/span> HALF2(a[idx]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> half2 reg_b &lt;span style="color:#666">=&lt;/span> HALF2(b[idx]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> half2 reg_c &lt;span style="color:#666">=&lt;/span> __hadd2(reg_a, reg_b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HALF2(c[idx]) &lt;span style="color:#666">=&lt;/span> reg_c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="fp16x8-kernel">fp16x8 kernel&lt;/h3>
&lt;p>This kernel extends the vectorization approach to process 8 half-precision values per thread, using four `half2` packed operations.
This maximizes memory throughput by loading 16 bytes (128 bits) per thread while maintaining efficient packed arithmetic.
The kernel includes proper bounds checking for each half2 pair to handle cases where the array size is not perfectly divisible by 8:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;#34;elementwise_add.cuh&amp;#34;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">elementwise_add_f16x8_kernel&lt;/span>(half&lt;span style="color:#666">*&lt;/span> __restrict__ a,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> half&lt;span style="color:#666">*&lt;/span> __restrict__ b,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> half&lt;span style="color:#666">*&lt;/span> __restrict__ c, &lt;span style="color:#902000">int&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> &lt;span style="color:#902000">int&lt;/span> linearThreadId &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> &lt;span style="color:#902000">int&lt;/span> idx &lt;span style="color:#666">=&lt;/span> linearThreadId &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#40a070">8&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> &lt;span style="color:#902000">int&lt;/span> remaining &lt;span style="color:#666">=&lt;/span> N &lt;span style="color:#666">-&lt;/span> idx;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (remaining &lt;span style="color:#666">&amp;lt;=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Fast path: full 8 elements
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (remaining &lt;span style="color:#666">&amp;gt;=&lt;/span> &lt;span style="color:#40a070">8&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Single 128-bit loads for A and B
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> float4 vec_a &lt;span style="color:#666">=&lt;/span> LDST128BITS(a[idx]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> float4 vec_b &lt;span style="color:#666">=&lt;/span> LDST128BITS(b[idx]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Reinterpret as four half2 lanes, compute, then store as 128-bit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">union&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">Pack16&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> float4 f4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> half2 h2[&lt;span style="color:#40a070">4&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } pa, pb, pc;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pa.f4 &lt;span style="color:#666">=&lt;/span> vec_a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pb.f4 &lt;span style="color:#666">=&lt;/span> vec_b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pc.h2[&lt;span style="color:#40a070">0&lt;/span>] &lt;span style="color:#666">=&lt;/span> __hadd2(pa.h2[&lt;span style="color:#40a070">0&lt;/span>], pb.h2[&lt;span style="color:#40a070">0&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pc.h2[&lt;span style="color:#40a070">1&lt;/span>] &lt;span style="color:#666">=&lt;/span> __hadd2(pa.h2[&lt;span style="color:#40a070">1&lt;/span>], pb.h2[&lt;span style="color:#40a070">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pc.h2[&lt;span style="color:#40a070">2&lt;/span>] &lt;span style="color:#666">=&lt;/span> __hadd2(pa.h2[&lt;span style="color:#40a070">2&lt;/span>], pb.h2[&lt;span style="color:#40a070">2&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pc.h2[&lt;span style="color:#40a070">3&lt;/span>] &lt;span style="color:#666">=&lt;/span> __hadd2(pa.h2[&lt;span style="color:#40a070">3&lt;/span>], pb.h2[&lt;span style="color:#40a070">3&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Single 128-bit store for C
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> LDST128BITS(c[idx]) &lt;span style="color:#666">=&lt;/span> pc.f4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Tail path: handle &amp;lt;8 remaining elements
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (; i &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span> remaining; i &lt;span style="color:#666">+=&lt;/span> &lt;span style="color:#40a070">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> half2 ra &lt;span style="color:#666">=&lt;/span> HALF2(a[idx &lt;span style="color:#666">+&lt;/span> i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> half2 rb &lt;span style="color:#666">=&lt;/span> HALF2(b[idx &lt;span style="color:#666">+&lt;/span> i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HALF2(c[idx &lt;span style="color:#666">+&lt;/span> i]) &lt;span style="color:#666">=&lt;/span> __hadd2(ra, rb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> remaining) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c[idx &lt;span style="color:#666">+&lt;/span> i] &lt;span style="color:#666">=&lt;/span> __hadd(a[idx &lt;span style="color:#666">+&lt;/span> i], b[idx &lt;span style="color:#666">+&lt;/span> i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="register-the-kernels-and-benchmark">Register the kernels and benchmark&lt;/h3>
&lt;p>Register the kernel:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#include&lt;/span> &lt;span style="color:#007020">&amp;#34;elementwise_add.cuh&amp;#34;&lt;/span>&lt;span style="color:#007020">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TORCH_BINDING_ELEM_ADD(f32, torch&lt;span style="color:#666">::&lt;/span>kFloat32, &lt;span style="color:#902000">float&lt;/span>, &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TORCH_BINDING_ELEM_ADD(f32x4, torch&lt;span style="color:#666">::&lt;/span>kFloat32, &lt;span style="color:#902000">float&lt;/span>, &lt;span style="color:#40a070">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TORCH_BINDING_ELEM_ADD(f16x2, torch&lt;span style="color:#666">::&lt;/span>kFloat16, half, &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TORCH_BINDING_ELEM_ADD(f16x8, torch&lt;span style="color:#666">::&lt;/span>kFloat16, half, &lt;span style="color:#40a070">8&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TORCH_BINDING_COMMON_EXTENSION(elementwise_add_f32)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TORCH_BINDING_COMMON_EXTENSION(elementwise_add_f32x4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TORCH_BINDING_COMMON_EXTENSION(elementwise_add_f16x2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TORCH_BINDING_COMMON_EXTENSION(elementwise_add_f16x8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Compile PyTorch module&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">setuptools&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> setup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">torch.utils.cpp_extension&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> BuildExtension, CppExtension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source_files &lt;span style="color:#666">=&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;elementwise_add_basic.cu&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;elementwise_add_f32x4.cu&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;elementwise_add_f16x2.cu&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;elementwise_add_f16x8.cu&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;elementwise_add_lib.cu&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>setup(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#39;elementwise_lib&amp;#39;&lt;/span>, &lt;span style="color:#60a0b0;font-style:italic"># The name of your module&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ext_modules&lt;span style="color:#666">=&lt;/span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CppExtension(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;elementwise_lib&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> source_files
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cmdclass&lt;span style="color:#666">=&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#39;build_ext&amp;#39;&lt;/span>: BuildExtension
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Launching in PyTorch:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">functools&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> partial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">from&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">typing&lt;/span> &lt;span style="color:#007020;font-weight:bold">import&lt;/span> Optional
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">torch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">os&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">sys&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>workspace &lt;span style="color:#666">=&lt;/span> os&lt;span style="color:#666">.&lt;/span>environ[&lt;span style="color:#4070a0">&amp;#34;__WORKSPACE__&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># The built torch lib is in the following path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lib_dir &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>workspace&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">/build/lib.linux-x86_64-cpython-312&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;lib: &lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>lib_dir&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sys&lt;span style="color:#666">.&lt;/span>path&lt;span style="color:#666">.&lt;/span>append(lib_dir)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">elementwise_lib&lt;/span> &lt;span style="color:#007020;font-weight:bold">as&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">lib&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>torch&lt;span style="color:#666">.&lt;/span>set_grad_enabled(&lt;span style="color:#007020;font-weight:bold">False&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;Compiling Torch kernel&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic"># Load the CUDA kernel as a python module&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">hashlib&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">import&lt;/span> &lt;span style="color:#0e84b5;font-weight:bold">os&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">get_file_hash&lt;/span>(filepath):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#4070a0">&amp;#34;&amp;#34;&amp;#34;Get MD5 hash of file content&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">with&lt;/span> &lt;span style="color:#007020">open&lt;/span>(filepath, &lt;span style="color:#4070a0">&amp;#39;rb&amp;#39;&lt;/span>) &lt;span style="color:#007020;font-weight:bold">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> hashlib&lt;span style="color:#666">.&lt;/span>md5(f&lt;span style="color:#666">.&lt;/span>read())&lt;span style="color:#666">.&lt;/span>hexdigest()[:&lt;span style="color:#40a070">8&lt;/span>] &lt;span style="color:#60a0b0;font-style:italic"># Use first 8 chars&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;running benchmark&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">def&lt;/span> &lt;span style="color:#06287e">run_benchmark&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perf_func: callable,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a: torch&lt;span style="color:#666">.&lt;/span>Tensor,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b: torch&lt;span style="color:#666">.&lt;/span>Tensor,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tag: &lt;span style="color:#007020">str&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out: Optional[torch&lt;span style="color:#666">.&lt;/span>Tensor] &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> warmup: &lt;span style="color:#007020">int&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">10&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iters: &lt;span style="color:#007020">int&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1000&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> show_all: &lt;span style="color:#007020">bool&lt;/span> &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#007020;font-weight:bold">False&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements_per_block &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">256&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> out &lt;span style="color:#007020;font-weight:bold">is&lt;/span> &lt;span style="color:#007020;font-weight:bold">not&lt;/span> &lt;span style="color:#007020;font-weight:bold">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out&lt;span style="color:#666">.&lt;/span>fill_(&lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Warmup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> _ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(warmup):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perf_func(a, b, out, elements_per_block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> torch&lt;span style="color:#666">.&lt;/span>cuda&lt;span style="color:#666">.&lt;/span>synchronize()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start_event &lt;span style="color:#666">=&lt;/span> torch&lt;span style="color:#666">.&lt;/span>cuda&lt;span style="color:#666">.&lt;/span>Event(enable_timing&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end_event &lt;span style="color:#666">=&lt;/span> torch&lt;span style="color:#666">.&lt;/span>cuda&lt;span style="color:#666">.&lt;/span>Event(enable_timing&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#007020;font-weight:bold">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start_event&lt;span style="color:#666">.&lt;/span>record()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> _ &lt;span style="color:#007020;font-weight:bold">in&lt;/span> &lt;span style="color:#007020">range&lt;/span>(iters):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> perf_func(a, b, out, elements_per_block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end_event&lt;span style="color:#666">.&lt;/span>record()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> torch&lt;span style="color:#666">.&lt;/span>cuda&lt;span style="color:#666">.&lt;/span>synchronize()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total_time &lt;span style="color:#666">=&lt;/span> start_event&lt;span style="color:#666">.&lt;/span>elapsed_time(end_event) &lt;span style="color:#60a0b0;font-style:italic"># ms&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mean_time &lt;span style="color:#666">=&lt;/span> total_time &lt;span style="color:#666">/&lt;/span> iters
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_info &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;out_&lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>tag&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_val &lt;span style="color:#666">=&lt;/span> out&lt;span style="color:#666">.&lt;/span>flatten()&lt;span style="color:#666">.&lt;/span>detach()&lt;span style="color:#666">.&lt;/span>cpu()&lt;span style="color:#666">.&lt;/span>numpy()&lt;span style="color:#666">.&lt;/span>tolist()[:&lt;span style="color:#40a070">2&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_val &lt;span style="color:#666">=&lt;/span> [&lt;span style="color:#007020">round&lt;/span>(v, &lt;span style="color:#40a070">8&lt;/span>) &lt;span style="color:#007020;font-weight:bold">for&lt;/span> v &lt;span style="color:#007020;font-weight:bold">in&lt;/span> out_val]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>out_info&lt;span style="color:#70a0d0">:&lt;/span>&lt;span style="color:#4070a0">&amp;gt;18&lt;/span>&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">: &lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>out_val&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">, time:&lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>mean_time&lt;span style="color:#70a0d0">:&lt;/span>&lt;span style="color:#4070a0">.8f&lt;/span>&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">ms&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> show_all:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(out)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> out, mean_time
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Run the benchmark:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>shapes &lt;span style="color:#666">=&lt;/span> [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#40a070">2096&lt;/span>, &lt;span style="color:#40a070">4096&lt;/span>), (&lt;span style="color:#40a070">2048&lt;/span>, &lt;span style="color:#40a070">2048&lt;/span>), (&lt;span style="color:#40a070">2048&lt;/span>, &lt;span style="color:#40a070">1024&lt;/span>), (&lt;span style="color:#40a070">1024&lt;/span>, &lt;span style="color:#40a070">1024&lt;/span>), (&lt;span style="color:#40a070">512&lt;/span>, &lt;span style="color:#40a070">512&lt;/span>), (&lt;span style="color:#40a070">256&lt;/span>, &lt;span style="color:#40a070">256&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">for&lt;/span> shape &lt;span style="color:#007020;font-weight:bold">in&lt;/span> shapes:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;Running benchmark for shape: &lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>shape&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A &lt;span style="color:#666">=&lt;/span> torch&lt;span style="color:#666">.&lt;/span>randn(&lt;span style="color:#666">*&lt;/span>shape, dtype&lt;span style="color:#666">=&lt;/span>torch&lt;span style="color:#666">.&lt;/span>float32, device&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;cuda&amp;#34;&lt;/span>)&lt;span style="color:#666">.&lt;/span>contiguous()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> B &lt;span style="color:#666">=&lt;/span> torch&lt;span style="color:#666">.&lt;/span>randn(&lt;span style="color:#666">*&lt;/span>shape, &lt;span style="color:#40a070">1024&lt;/span>, dtype&lt;span style="color:#666">=&lt;/span>torch&lt;span style="color:#666">.&lt;/span>float32, device&lt;span style="color:#666">=&lt;/span>&lt;span style="color:#4070a0">&amp;#34;cuda&amp;#34;&lt;/span>)&lt;span style="color:#666">.&lt;/span>contiguous()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> C &lt;span style="color:#666">=&lt;/span> torch&lt;span style="color:#666">.&lt;/span>zeros_like(A)&lt;span style="color:#666">.&lt;/span>contiguous()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Create fp16 tensors for fp16 kernels&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> A_fp16 &lt;span style="color:#666">=&lt;/span> A&lt;span style="color:#666">.&lt;/span>half()&lt;span style="color:#666">.&lt;/span>contiguous()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> B_fp16 &lt;span style="color:#666">=&lt;/span> B&lt;span style="color:#666">.&lt;/span>half()&lt;span style="color:#666">.&lt;/span>contiguous()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> C_fp16 &lt;span style="color:#666">=&lt;/span> torch&lt;span style="color:#666">.&lt;/span>zeros_like(A_fp16)&lt;span style="color:#666">.&lt;/span>contiguous()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements_per_block &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">256&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;elements_per_block: &lt;/span>&lt;span style="color:#70a0d0">{&lt;/span>elements_per_block&lt;span style="color:#70a0d0">}&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic"># Increase elements_per_block to make sure that each kernel has same threads_per_block&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run_benchmark(lib&lt;span style="color:#666">.&lt;/span>elementwise_add_f32, A, B, &lt;span style="color:#4070a0">&amp;#34;basic&amp;#34;&lt;/span>, C, elements_per_block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run_benchmark(lib&lt;span style="color:#666">.&lt;/span>elementwise_add_f32x4, A, B, &lt;span style="color:#4070a0">&amp;#34;f32x4&amp;#34;&lt;/span>, C, elements_per_block &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#40a070">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run_benchmark(lib&lt;span style="color:#666">.&lt;/span>elementwise_add_f16x2, A_fp16, B_fp16, &lt;span style="color:#4070a0">&amp;#34;f16x2&amp;#34;&lt;/span>, C_fp16, elements_per_block &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run_benchmark(lib&lt;span style="color:#666">.&lt;/span>elementwise_add_f16x8, A_fp16, B_fp16, &lt;span style="color:#4070a0">&amp;#34;f16x8&amp;#34;&lt;/span>, C_fp16, elements_per_block &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#40a070">8&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020">print&lt;/span>(&lt;span style="color:#4070a0">f&lt;/span>&lt;span style="color:#4070a0">&amp;#34;--&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Results:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span> lib: /workspace/project/superjomn.github.io/content-org/_build/build/lib.linux-x86_64-cpython-312
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Compiling Torch kernel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> running benchmark
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Running benchmark for shape: (2096, 4096)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements_per_block: 256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_basic: [0.62899578, -3.16506243], time:0.04013546ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f32x4: [0.62899578, -3.16506243], time:0.03716669ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x2: [0.62890625, -3.1640625], time:0.02376186ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x8: [0.62890625, -3.1640625], time:0.02382634ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Running benchmark for shape: (2048, 2048)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements_per_block: 256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_basic: [0.98603237, -2.21596098], time:0.02142691ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f32x4: [0.98603237, -2.21596098], time:0.01876467ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x2: [0.98632812, -2.21484375], time:0.01224410ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x8: [0.98632812, -2.21484375], time:0.01231584ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Running benchmark for shape: (2048, 1024)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements_per_block: 256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_basic: [-1.68364513, 0.07630849], time:0.00754973ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f32x4: [-1.68364513, 0.07630849], time:0.00768909ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x2: [-1.68359375, 0.07666016], time:0.00720714ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x8: [-1.68359375, 0.07666016], time:0.00725242ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Running benchmark for shape: (1024, 1024)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements_per_block: 256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_basic: [0.41730967, -2.56410193], time:0.00473962ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f32x4: [0.41730967, -2.56410193], time:0.00490102ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x2: [0.41723633, -2.56445312], time:0.00471936ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x8: [0.41723633, -2.56445312], time:0.00484266ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Running benchmark for shape: (512, 512)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements_per_block: 256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_basic: [-0.84098238, -0.51086581], time:0.00448192ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f32x4: [-0.84098238, -0.51086581], time:0.00438221ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x2: [-0.84130859, -0.51074219], time:0.00443571ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x8: [-0.84130859, -0.51074219], time:0.00444208ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Running benchmark for shape: (256, 256)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements_per_block: 256
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_basic: [2.76621795, 1.71955645], time:0.00438445ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f32x4: [2.76621795, 1.71955645], time:0.00440973ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x2: [2.765625, 1.71972656], time:0.00444272ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out_f16x8: [2.765625, 1.71972656], time:0.00445354ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Reduce kernel in CUDA</title><link>/posts/reduce-cuda/</link><pubDate>Mon, 25 Mar 2024 00:00:00 +0000</pubDate><guid>/posts/reduce-cuda/</guid><description>&lt;h2 id="question-definition">Question definition&lt;/h2>
&lt;p>Given an array of \(n\) integers, the goal is to compute the sum of all elements within the array.&lt;/p>
&lt;h2 id="solutions">Solutions&lt;/h2>
&lt;p>The implementations for all kernel versions can be found at &lt;a href="https://github.com/Superjomn/cuda-from-scratch/blob/dev/2-reduce.cu">2-reduce.cu on GitHub&lt;/a>.&lt;/p>
&lt;h3 id="naive-version-with-atomicadd">Naive Version with &lt;code>atomicAdd&lt;/code>&lt;/h3>
&lt;p>The simplest approach involves utilizing each thread to perform an &lt;code>atomicAdd&lt;/code> operation on the output variable. Here&amp;rsquo;s how the kernel is defined:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">reduce_naive_atomic&lt;/span>(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> idx &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> gridSize &lt;span style="color:#666">=&lt;/span> blockDim.x &lt;span style="color:#666">*&lt;/span> gridDim.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> sum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (&lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> idx; i &lt;span style="color:#666">&amp;lt;&lt;/span> n; i &lt;span style="color:#666">+=&lt;/span> gridSize)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#666">+=&lt;/span> g_idata[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> atomicAdd(g_odata, sum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And the kernel launcher is straightforward, invoking the kernel a single time:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#902000">int&lt;/span> &lt;span style="color:#06287e">launch_reduce&lt;/span>(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n, &lt;span style="color:#902000">int&lt;/span> block_size, kernel_fn kernel, cudaStream_t stream)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> idata &lt;span style="color:#666">=&lt;/span> g_idata;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> odata &lt;span style="color:#666">=&lt;/span> g_odata;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">uint32_t&lt;/span> num_warps &lt;span style="color:#666">=&lt;/span> block_size &lt;span style="color:#666">/&lt;/span> &lt;span style="color:#40a070">32&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> smem_size &lt;span style="color:#666">=&lt;/span> num_warps &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#007020;font-weight:bold">sizeof&lt;/span>(&lt;span style="color:#902000">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> num_blocks &lt;span style="color:#666">=&lt;/span> ceil(n, block_size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Launch the kernel
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> kernel&lt;span style="color:#666">&amp;lt;&amp;lt;&amp;lt;&lt;/span>num_blocks, block_size, smem_size, stream&lt;span style="color:#666">&amp;gt;&amp;gt;&amp;gt;&lt;/span>(idata, odata, n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (&lt;span style="color:#666">!&lt;/span>FLAGS_profile)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cudaStreamSynchronize(stream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Copy the final result back to the host
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#902000">int&lt;/span> h_out;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NVCHECK(cudaMemcpyAsync(&lt;span style="color:#666">&amp;amp;&lt;/span>h_out, odata, &lt;span style="color:#007020;font-weight:bold">sizeof&lt;/span>(&lt;span style="color:#902000">int&lt;/span>), cudaMemcpyDeviceToHost, stream));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> h_out;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When tested on a GTX 4080, this method achieved a throughput of approximately 82GB/s.&lt;/p>
&lt;h3 id="tiled-reduction-with-shared-memory">Tiled Reduction with Shared Memory&lt;/h3>
&lt;p>A classical approach involves leveraging a thread block to perform local reductions on a tile within shared memory.
This method encompasses several kernel versions, each with different optimizations.&lt;/p>
&lt;h4 id="basic-version">Basic version&lt;/h4>
&lt;p>The initial implementation is as below:&lt;/p>
&lt;ol>
&lt;li>A tile of data is collaboratively loaded into shared memory.&lt;/li>
&lt;li>A partial reduction on this data tile is executed within a thread block, get the sum of the tile.&lt;/li>
&lt;li>The sum is then written to a designated spot in the global memory&amp;rsquo;s output slot. It&amp;rsquo;s important to note that this kernel requires a temporary buffer for writing partial results from each thread block.&lt;/li>
&lt;li>The process repeats with the size \(n\) reduced to \(\frac{n}{blockSize}\), continuing until \(n=1\).&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">reduce_smem_naive&lt;/span>(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">extern&lt;/span> __shared__ &lt;span style="color:#902000">int&lt;/span> sdata[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> tid &lt;span style="color:#666">=&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Read a block of data into shared memory collectively
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> sdata[tid] &lt;span style="color:#666">=&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> n) &lt;span style="color:#666">?&lt;/span> g_idata[i] &lt;span style="color:#666">:&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (&lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> stride &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>; stride &lt;span style="color:#666">&amp;lt;&lt;/span> blockDim.x; stride &lt;span style="color:#666">*=&lt;/span> &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// ISSUE: divergent warps
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (tid &lt;span style="color:#666">%&lt;/span> (&lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">*&lt;/span> stride) &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sdata[tid] &lt;span style="color:#666">+=&lt;/span> sdata[tid &lt;span style="color:#666">+&lt;/span> stride];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads(); &lt;span style="color:#60a0b0;font-style:italic">// need to sync per level
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Write the result for this block to global memory
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (tid &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> g_odata[blockIdx.x] &lt;span style="color:#666">=&lt;/span> sdata[&lt;span style="color:#40a070">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Launching this kernel multiple times involves a slightly more complex launcher:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#902000">int&lt;/span> &lt;span style="color:#06287e">launch_reduce&lt;/span>(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n, &lt;span style="color:#902000">int&lt;/span> block_size, kernel_fn kernel, cudaStream_t stream,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">uint32_t&lt;/span> num_blocks, &lt;span style="color:#902000">uint32_t&lt;/span> smem_size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> idata &lt;span style="color:#666">=&lt;/span> g_idata;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> odata &lt;span style="color:#666">=&lt;/span> g_odata;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (smem_size &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smem_size &lt;span style="color:#666">=&lt;/span> block_size &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#007020;font-weight:bold">sizeof&lt;/span>(&lt;span style="color:#902000">int&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Calculate the number of blocks
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> num_blocks &lt;span style="color:#666">=&lt;/span> (num_blocks &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">0&lt;/span>) &lt;span style="color:#666">?&lt;/span> &lt;span style="color:#002070;font-weight:bold">num_blocks&lt;/span> : (n &lt;span style="color:#666">+&lt;/span> block_size &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#666">/&lt;/span> block_size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (&lt;span style="color:#666">!&lt;/span>FLAGS_profile)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#4070a0">&amp;#34;- launching: num_blocks: %d, block_size:%d, n:%d&lt;/span>&lt;span style="color:#4070a0;font-weight:bold">\n&lt;/span>&lt;span style="color:#4070a0">&amp;#34;&lt;/span>, num_blocks, block_size, n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> level &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Launch the kernel
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> kernel&lt;span style="color:#666">&amp;lt;&amp;lt;&amp;lt;&lt;/span>num_blocks, block_size, smem_size, stream&lt;span style="color:#666">&amp;gt;&amp;gt;&amp;gt;&lt;/span>(idata, odata, n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (&lt;span style="color:#666">!&lt;/span>FLAGS_profile)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cudaStreamSynchronize(stream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> level&lt;span style="color:#666">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Recursively reduce the partial sums
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> (num_blocks &lt;span style="color:#666">&amp;gt;&lt;/span> &lt;span style="color:#40a070">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#666">::&lt;/span>swap(idata, odata);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#666">=&lt;/span> num_blocks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num_blocks &lt;span style="color:#666">=&lt;/span> (n &lt;span style="color:#666">+&lt;/span> block_size &lt;span style="color:#666">-&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#666">/&lt;/span> block_size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kernel&lt;span style="color:#666">&amp;lt;&amp;lt;&amp;lt;&lt;/span>num_blocks, block_size, smem_size, stream&lt;span style="color:#666">&amp;gt;&amp;gt;&amp;gt;&lt;/span>(idata, odata, n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (&lt;span style="color:#666">!&lt;/span>FLAGS_profile)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cudaStreamSynchronize(stream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Copy the final result back to the host
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#902000">int&lt;/span> h_out;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NVCHECK(cudaMemcpyAsync(&lt;span style="color:#666">&amp;amp;&lt;/span>h_out, odata, &lt;span style="color:#007020;font-weight:bold">sizeof&lt;/span>(&lt;span style="color:#902000">int&lt;/span>), cudaMemcpyDeviceToHost, stream));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> h_out;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>All tiled reduction kenrels utilize the aforementioned launcher, achieving a throughput of 54GB/s. This is less efficient compared to the atomic naive version, which reaches 82GB/s.&lt;/p>
&lt;h4 id="avoid-thread-divergence">Avoid thread divergence&lt;/h4>
&lt;p>The basic version encounters significant thread divergence, particularly noticeable at &lt;code>if (tid % (2 * stride) == 0)&lt;/code>.
Here is an optimized variant:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">reduce_smem_1_avoid_divergent_warps&lt;/span>(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">extern&lt;/span> __shared__ &lt;span style="color:#902000">int&lt;/span> sdata[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> tid &lt;span style="color:#666">=&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sdata[tid] &lt;span style="color:#666">=&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> n) &lt;span style="color:#666">?&lt;/span> g_idata[i] &lt;span style="color:#666">:&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (&lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> stride &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>; stride &lt;span style="color:#666">&amp;lt;&lt;/span> blockDim.x; stride &lt;span style="color:#666">*=&lt;/span> &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> index &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">*&lt;/span> stride &lt;span style="color:#666">*&lt;/span> tid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (index &lt;span style="color:#666">&amp;lt;&lt;/span> blockDim.x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Issue: bank conflict
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> sdata[index] &lt;span style="color:#666">+=&lt;/span> sdata[index &lt;span style="color:#666">+&lt;/span> stride];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (tid &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> g_odata[blockIdx.x] &lt;span style="color:#666">=&lt;/span> sdata[&lt;span style="color:#40a070">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The optimization yields a 70GB/s throughput, marking a 29% improvement over the basic version.&lt;/p>
&lt;h4 id="read-two-elements-one-time">Read two elements one time&lt;/h4>
&lt;p>The preceding version&amp;rsquo;s DRAM throughput was only 20.63%, likely due to&lt;/p>
&lt;ol>
&lt;li>Insufficient grid size for small inputs, leading to underutilized thread resources.&lt;/li>
&lt;li>Each thread reading a single element at a time, given the fixed number of resident thread blocks per SM for a specific kernel, results in a limited number of load instructions issued.&lt;/li>
&lt;/ol>
&lt;p>To enhance DRAM throughput, especially for smaller grid sizes, threads can be configured to read more than one element at a time.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">reduce_smem_3_read_two&lt;/span>(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">extern&lt;/span> __shared__ &lt;span style="color:#902000">int&lt;/span> sdata[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> tid &lt;span style="color:#666">=&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> (blockDim.x &lt;span style="color:#666">*&lt;/span> &lt;span style="color:#40a070">2&lt;/span>) &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#define GET_ELEM(__idx) ((__idx) &amp;lt; n ? g_idata[(__idx)] : 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sdata[tid] &lt;span style="color:#666">=&lt;/span> GET_ELEM(i) &lt;span style="color:#666">+&lt;/span> GET_ELEM(i &lt;span style="color:#666">+&lt;/span> blockDim.x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (&lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> stride &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">1&lt;/span>; stride &lt;span style="color:#666">&amp;lt;&lt;/span> blockDim.x; stride &lt;span style="color:#666">*=&lt;/span> &lt;span style="color:#40a070">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> index &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">2&lt;/span> &lt;span style="color:#666">*&lt;/span> stride &lt;span style="color:#666">*&lt;/span> tid;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (index &lt;span style="color:#666">&amp;lt;&lt;/span> blockDim.x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Issue: bank conflict
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> sdata[index] &lt;span style="color:#666">+=&lt;/span> sdata[index &lt;span style="color:#666">+&lt;/span> stride];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (tid &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> g_odata[blockIdx.x] &lt;span style="color:#666">=&lt;/span> sdata[&lt;span style="color:#40a070">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This approach improves the DRAM Throughput to 33.78%, a significant 63.72% increase over the previous method.
The overall throughput reaches 96.51GB/s, demonstrating 37.87% enhancement from the 70GB/s achieved earlier.&lt;/p>
&lt;h3 id="tiled-reduction-with-warp-shuffle">Tiled Reduction with Warp Shuffle&lt;/h3>
&lt;p>Modern GPUs facilitate direct data exchange within a warp, bypassing the need for shared memory.&lt;/p>
&lt;p>The function below demonstrates how to conduct a reduction within a single warp using the warp shuffle instruction, as highlighted in the book &amp;lt;Professional CUDA C Programming&amp;gt;.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// using warp shuffle instruction
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// From book &amp;lt;Professional CUDA C Programming&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>__inline__ __device__ &lt;span style="color:#902000">int&lt;/span> &lt;span style="color:#06287e">warpReduce&lt;/span>(&lt;span style="color:#902000">int&lt;/span> mySum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">+=&lt;/span> __shfl_xor(mySum, &lt;span style="color:#40a070">16&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">+=&lt;/span> __shfl_xor(mySum, &lt;span style="color:#40a070">8&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">+=&lt;/span> __shfl_xor(mySum, &lt;span style="color:#40a070">4&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">+=&lt;/span> __shfl_xor(mySum, &lt;span style="color:#40a070">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">+=&lt;/span> __shfl_xor(mySum, &lt;span style="color:#40a070">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">return&lt;/span> mySum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Utilizing shared memory to store the sum computed by each warp and subsequently reducing these sums as previously described enables the calculation of a thread block&amp;rsquo;s total sum.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> &lt;span style="color:#06287e">reduce_warp_shlf&lt;/span>(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Helps to share data between warps
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// size should be (blockDim.x / warpSize)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">extern&lt;/span> __shared__ &lt;span style="color:#902000">int&lt;/span> sdata[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> idx &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Necessary to make sure shfl instruction is not used with uninitialized data
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#902000">int&lt;/span> mySum &lt;span style="color:#666">=&lt;/span> idx &lt;span style="color:#666">&amp;lt;&lt;/span> n &lt;span style="color:#666">?&lt;/span> g_idata[idx] &lt;span style="color:#666">:&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> lane &lt;span style="color:#666">=&lt;/span> threadIdx.x &lt;span style="color:#666">%&lt;/span> warpSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> warp &lt;span style="color:#666">=&lt;/span> threadIdx.x &lt;span style="color:#666">/&lt;/span> warpSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">=&lt;/span> warpReduce(mySum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (lane &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sdata[warp] &lt;span style="color:#666">=&lt;/span> mySum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// last warp reduce
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> mySum &lt;span style="color:#666">=&lt;/span> (threadIdx.x &lt;span style="color:#666">&amp;lt;&lt;/span> blockDim.x &lt;span style="color:#666">/&lt;/span> warpSize) &lt;span style="color:#666">?&lt;/span> sdata[lane] &lt;span style="color:#666">:&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (warp &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">=&lt;/span> warpReduce(mySum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (threadIdx.x &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> g_odata[blockIdx.x] &lt;span style="color:#666">=&lt;/span> mySum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Despite reading only a single element per thread, this kernel can achieve a throughput of 96GB/s, outperforming the shared memory version&amp;rsquo;s 70GB/s.
Furthermore, the kernel can be modified to read \(NT\) elements at a time for enhanced efficiency:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#902000">int&lt;/span> NT&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> reduce_warp_shlf_read_N(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Helps to share data between warps
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// size should be (blockDim.x / warpSize)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">extern&lt;/span> __shared__ &lt;span style="color:#902000">int&lt;/span> sdata[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> blockSize &lt;span style="color:#666">=&lt;/span> NT &lt;span style="color:#666">*&lt;/span> blockDim.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> idx &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockSize &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Necessary to make sure shfl instruction is not used with uninitialized data
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020">#define GET_ELEM(__idx) ((__idx) &amp;lt; n ? g_idata[(__idx)] : 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span> &lt;span style="color:#902000">int&lt;/span> mySum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#pragma unroll
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (&lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>; i &lt;span style="color:#666">&amp;lt;&lt;/span> NT; i&lt;span style="color:#666">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">+=&lt;/span> GET_ELEM(idx &lt;span style="color:#666">+&lt;/span> i &lt;span style="color:#666">*&lt;/span> blockDim.x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> lane &lt;span style="color:#666">=&lt;/span> threadIdx.x &lt;span style="color:#666">%&lt;/span> warpSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> warp &lt;span style="color:#666">=&lt;/span> threadIdx.x &lt;span style="color:#666">/&lt;/span> warpSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">=&lt;/span> warpReduce(mySum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (lane &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sdata[warp] &lt;span style="color:#666">=&lt;/span> mySum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// last warp reduce
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> mySum &lt;span style="color:#666">=&lt;/span> (threadIdx.x &lt;span style="color:#666">&amp;lt;&lt;/span> blockDim.x &lt;span style="color:#666">/&lt;/span> warpSize) &lt;span style="color:#666">?&lt;/span> sdata[lane] &lt;span style="color:#666">:&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (warp &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">=&lt;/span> warpReduce(mySum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (threadIdx.x &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> g_odata[blockIdx.x] &lt;span style="color:#666">=&lt;/span> mySum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Performance varies with different \(N\) values, as summarized below:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>NT&lt;/th>
&lt;th>throughput (GB/s)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>96.3187&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>96.2341&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>96.8153&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>107.226&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="warp-shuffle-combined-with-atomic-operations">Warp Shuffle Combined with Atomic Operations&lt;/h3>
&lt;p>Compared to tiled reduction solutions, utilizing &lt;code>atomicAdd&lt;/code> eliminates the need for a temporary buffer and requires only a single kernel launch.
This segment explores combining warp shuffle and atomic operations for efficient reduction.&lt;/p>
&lt;p>The kernel template below demonstrates this approach, utilizing warp shuffle instructions to enhance the warp reduction performance, and leveraging atomic operations to write directly to the output slot without the need for temporary buffer and multiple kernel launches.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#902000">int&lt;/span> NT&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> reduce_warp_shlf_read_N_atomic(&lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_idata, &lt;span style="color:#902000">int&lt;/span>&lt;span style="color:#666">*&lt;/span> g_odata, &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// Helps to share data between warps
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// size should be (blockDim.x / warpSize)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#007020;font-weight:bold">extern&lt;/span> __shared__ &lt;span style="color:#902000">int&lt;/span> sdata[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> blockSize &lt;span style="color:#666">=&lt;/span> NT &lt;span style="color:#666">*&lt;/span> blockDim.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">unsigned&lt;/span> &lt;span style="color:#902000">int&lt;/span> idx &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockSize &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// Necessary to make sure shfl instruction is not used with uninitialized data
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">// This only needs one turn of launch
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span>&lt;span style="color:#007020">#define GET_ELEM(__idx) ((__idx) &amp;lt; n ? g_idata[(__idx)] : 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span> &lt;span style="color:#902000">int&lt;/span> mySum &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">#pragma unroll
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020">&lt;/span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (&lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>; i &lt;span style="color:#666">&amp;lt;&lt;/span> NT; i&lt;span style="color:#666">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">+=&lt;/span> GET_ELEM(idx &lt;span style="color:#666">+&lt;/span> i &lt;span style="color:#666">*&lt;/span> blockDim.x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> lane &lt;span style="color:#666">=&lt;/span> threadIdx.x &lt;span style="color:#666">%&lt;/span> warpSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> warp &lt;span style="color:#666">=&lt;/span> threadIdx.x &lt;span style="color:#666">/&lt;/span> warpSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">=&lt;/span> warpReduce(mySum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (lane &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sdata[warp] &lt;span style="color:#666">=&lt;/span> mySum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// last warp reduce
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> mySum &lt;span style="color:#666">=&lt;/span> (threadIdx.x &lt;span style="color:#666">&amp;lt;&lt;/span> blockDim.x &lt;span style="color:#666">/&lt;/span> warpSize) &lt;span style="color:#666">?&lt;/span> sdata[lane] &lt;span style="color:#666">:&lt;/span> &lt;span style="color:#40a070">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (warp &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mySum &lt;span style="color:#666">=&lt;/span> warpReduce(mySum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (threadIdx.x &lt;span style="color:#666">==&lt;/span> &lt;span style="color:#40a070">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> atomicAdd(g_odata, mySum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Remarkably, this kernel achieves a throughput of 121.777 GB/s under the same conditions.&lt;/p>
&lt;h2 id="benchmark">Benchmark&lt;/h2>
&lt;p>The benchmark results illustrate the performance of different CUDA optimization strategies under varying conditions.&lt;/p>
&lt;figure>&lt;img src="/ox-hugo/2024-04-06_16-47-39_screenshot.png">
&lt;/figure>
&lt;p>Note that the optimal kernel configuration may vary depending on the size of the input data(\(n\)).&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://developer.download.nvidia.com/assets/cuda/files/reduction.pdf">Optimizing Parallel Reduction in CUDA&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.nvidia.com/blog/faster-parallel-reductions-kepler/">Faster Parallel Reductions on Kepler | NVIDIA Technical Blog&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Memory coalescing in CUDA (2) – Matrix Transpose</title><link>/posts/cuda-memory-coalescing-access-matrix-transpose/</link><pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate><guid>/posts/cuda-memory-coalescing-access-matrix-transpose/</guid><description>&lt;h2 id="background">Background&lt;/h2>
&lt;p>In the &lt;a href="https://superjomn.github.io/posts/cuda-memory-coalescing-access/">VecAdd&lt;/a> page, we&amp;rsquo;ve introduced the memory coalescing in global memory access. This post will follow the topic with another interesting application: Matrix transposing.&lt;/p>
&lt;p>The following content will briefly touch on the following topics:&lt;/p>
&lt;ul>
&lt;li>Tiles in matrix, this is the basis of optimization matrix computation&lt;/li>
&lt;li>A simple trick to avoid bank conflict in shared memory access&lt;/li>
&lt;/ul>
&lt;h2 id="kernels">Kernels&lt;/h2>
&lt;p>The code for all the kernels locates in &lt;a href="https://github.com/Superjomn/cuda-from-scratch/blob/dev/1-matrix-transpose-coalesce.cu">1-matrix-transpose-coalesce.cu&lt;/a>.&lt;/p>
&lt;h3 id="read-coalesced">Read coalesced&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#007020;font-weight:bold">typename&lt;/span> T&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> transpose_read_coalesce(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ input,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#666">*&lt;/span> __restrict__ output,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> n,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x; &lt;span style="color:#60a0b0;font-style:italic">// the contiguous tid
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#902000">int&lt;/span> j &lt;span style="color:#666">=&lt;/span> blockIdx.y &lt;span style="color:#666">*&lt;/span> blockDim.y &lt;span style="color:#666">+&lt;/span> threadIdx.y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> n &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output[i &lt;span style="color:#666">*&lt;/span> m &lt;span style="color:#666">+&lt;/span> j] &lt;span style="color:#666">=&lt;/span> input[j &lt;span style="color:#666">*&lt;/span> n &lt;span style="color:#666">+&lt;/span> i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="write-coalesced">Write coalesced&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#007020;font-weight:bold">typename&lt;/span> T&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> transpose_write_coalesce(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ input,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#666">*&lt;/span> __restrict__ output,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> n,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x; &lt;span style="color:#60a0b0;font-style:italic">// the contiguous tid
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#902000">int&lt;/span> j &lt;span style="color:#666">=&lt;/span> blockIdx.y &lt;span style="color:#666">*&lt;/span> blockDim.y &lt;span style="color:#666">+&lt;/span> threadIdx.y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> n &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output[j &lt;span style="color:#666">*&lt;/span> n &lt;span style="color:#666">+&lt;/span> i] &lt;span style="color:#666">=&lt;/span> input[i &lt;span style="color:#666">*&lt;/span> m &lt;span style="color:#666">+&lt;/span> j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="both-read-and-write-coalesced-by-tiling-with-shared-memory">Both read and write coalesced by tiling with shared memory&lt;/h3>
&lt;p>The tiling method is a common methodology for optimizing matrix operation. It divides the matrix into smaller, manageable blocks or &amp;ldquo;tiles&amp;rdquo; that can fit into shared memory.&lt;/p>
&lt;p>Let&amp;rsquo;s divide the matrix into tiles of size \(TILE \times TILE\), and the overall transpose could be decoupled into two sub-levels:&lt;/p>
&lt;ol>
&lt;li>the inter-tile transpose, that is move the tile to the target position; and secondly,&lt;/li>
&lt;li>the intra-tile transpose, that is transpose the elements within a single tile&lt;/li>
&lt;/ol>
&lt;h4 id="inter-tile-transpose">Inter-tile transpose&lt;/h4>
&lt;figure>&lt;img src="/ox-hugo/inter-tile.png">
&lt;/figure>
&lt;p>Each tile is processed by a thread block, so the tile coordinate is &lt;code>(blockIdx.y, blockIdx.x)&lt;/code>, and the target coord is &lt;code>(blockIdx.x, blockIdx.y)&lt;/code>.&lt;/p>
&lt;p>We can continue to process the elements within each tile.&lt;/p>
&lt;h4 id="intra-tile-transpose">Intra-tile transpose&lt;/h4>
&lt;figure>&lt;img src="/ox-hugo/intra-tile.png">
&lt;/figure>
&lt;p>Within a tile, we will read the elements, store the transposed version in the shared memory, and then store the tile in global memory, with the coord determined by the intra-tile transpose phase.&lt;/p>
&lt;p>There are two copies:&lt;/p>
&lt;ol>
&lt;li>Copying the tile from the input matrix and storing a transposed version into shared memory&lt;/li>
&lt;li>Copying the tile from shared memory into the output matrix in global memory&lt;/li>
&lt;/ol>
&lt;p>Only one side is in global memory in both copies, so it can perform a memory coalescing access pattern. Both copies are performed by all the threads collectively within a thread block.&lt;/p>
&lt;p>To make a coalesced memory access, in the first copy, a thread reads element of coord of &lt;code>(threadIdx.y, threadIdx.x)&lt;/code>, and the memory offset &lt;code>threadIdx.y * M + threadIdx.x&lt;/code> is contignuous for adjacent threads.
In the second copy, the thread block needs to copy a tile to global memory, similarly, a thread should process the element of &lt;code>(threadIdx.y, threadIdx.x)&lt;/code> in the output tile.&lt;/p>
&lt;h4 id="kernel-with-constant-tile-size">Kernel with constant tile size&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#007020;font-weight:bold">typename&lt;/span> T, &lt;span style="color:#902000">int&lt;/span> TILE&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> transpose_tiled_coalesce0(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ input,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#666">*&lt;/span> __restrict__ output,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> n,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(blockDim.x &lt;span style="color:#666">==&lt;/span> blockDim.y &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> blockDim.x &lt;span style="color:#666">==&lt;/span> TILE_DIM);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#60a0b0;font-style:italic">// TILE + 1 to avoid bank conflict
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// By padding the shared memory array with an extra element, the consecutive threads access
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> &lt;span style="color:#60a0b0;font-style:italic">// memory locations that fall into different banks to avoid bank conflict
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#60a0b0;font-style:italic">&lt;/span> __shared__ T tile[TILE][TILE &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> blockIdx.y &lt;span style="color:#666">*&lt;/span> blockDim.y &lt;span style="color:#666">+&lt;/span> threadIdx.y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> j &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> m &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tile[threadIdx.x][threadIdx.y] &lt;span style="color:#666">=&lt;/span> input[i &lt;span style="color:#666">*&lt;/span> n &lt;span style="color:#666">+&lt;/span> j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#666">=&lt;/span> blockIdx.y &lt;span style="color:#666">*&lt;/span> blockDim.y &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> n &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output[i &lt;span style="color:#666">*&lt;/span> m &lt;span style="color:#666">+&lt;/span> j] &lt;span style="color:#666">=&lt;/span> tile[threadIdx.y][threadIdx.x];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Note that, since each thread processes only one element, so both &lt;code>blockDim.x&lt;/code> and &lt;code>blockDim.y&lt;/code> should equal to &lt;code>TILE&lt;/code>, and &lt;code>TILE&lt;/code> is a constant value.&lt;/p>
&lt;h4 id="kernel-with-dynamic-tile-size">Kernel with dynamic tile size&lt;/h4>
&lt;p>It is possible to allocate the shared memory dynamically, making the &lt;code>TILE&lt;/code> a variable that could be assigned with &lt;code>blockDim.x&lt;/code> or &lt;code>blockDim.y&lt;/code> on the fly.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C++" data-lang="C++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#007020;font-weight:bold">typename&lt;/span> T&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> transpose_tiled_coalesce1(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ input,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#666">*&lt;/span> __restrict__ output,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> n,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> size_t TILE &lt;span style="color:#666">=&lt;/span> blockDim.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(blockDim.x &lt;span style="color:#666">==&lt;/span> blockDim.y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">extern&lt;/span> __shared__ T tile[];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> blockIdx.y &lt;span style="color:#666">*&lt;/span> blockDim.y &lt;span style="color:#666">+&lt;/span> threadIdx.y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> j &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> m &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tile[threadIdx.x &lt;span style="color:#666">*&lt;/span> (TILE &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#666">+&lt;/span> threadIdx.y] &lt;span style="color:#666">=&lt;/span> input[i &lt;span style="color:#666">*&lt;/span> n &lt;span style="color:#666">+&lt;/span> j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __syncthreads();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#666">=&lt;/span> blockIdx.y &lt;span style="color:#666">*&lt;/span> blockDim.y &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> n &lt;span style="color:#666">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#666">&amp;lt;&lt;/span> m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output[i &lt;span style="color:#666">*&lt;/span> m &lt;span style="color:#666">+&lt;/span> j] &lt;span style="color:#666">=&lt;/span> tile[threadIdx.y &lt;span style="color:#666">*&lt;/span> (TILE &lt;span style="color:#666">+&lt;/span> &lt;span style="color:#40a070">1&lt;/span>) &lt;span style="color:#666">+&lt;/span> threadIdx.x];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="performance">Performance&lt;/h2>
&lt;p>In NVIDIA GTX 3080, these kernels have a pretty close performance:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Kernel&lt;/th>
&lt;th>Latency&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Read coalesced&lt;/td>
&lt;td>0.0476&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Write coalesced&lt;/td>
&lt;td>0.0474&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>tiled&lt;/td>
&lt;td>0.0478&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://leimao.github.io/blog/CUDA-Coalesced-Memory-Access/">CUDA Coalesced Memory Access - blog of Lei Mao&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Memory coalescing in CUDA (1) – VecAdd</title><link>/posts/cuda-memory-coalescing-access/</link><pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate><guid>/posts/cuda-memory-coalescing-access/</guid><description>&lt;h2 id="background">Background&lt;/h2>
&lt;p>&lt;strong>Memory coalescing&lt;/strong> is a crucial optimization technique in CUDA programming that allows optimal usage of the &lt;strong>global memory bandwidth&lt;/strong>. When threads in the same warp running the same instruction access to &lt;strong>consecutive locations&lt;/strong> in the global memory, the hardware can coalesce these accesses into a single transaction, significantly improving performance.&lt;/p>
&lt;p>Coalescing memory access is vital for achieving high performance. Besides PCIe memory traffic, accessing global memory tends to be the largest bottleneck in GPU&amp;rsquo;s memory hierarchy.
Non-coalesced memory access can lead to underutilization of memory bandwidth.&lt;/p>
&lt;p>In the following post, we will delve deeper into memory coalescing with CUDA code for the classical vector adding.&lt;/p>
&lt;h2 id="vecadd">VecAdd&lt;/h2>
&lt;p>There are three kernels in below. The complete code locates &lt;a href="https://github.com/Superjomn/cuda-from-scratch/blob/dev/0-vecadd-memory-coalesce.cu">here&lt;/a>.&lt;/p>
&lt;h3 id="naive-vecadd-kernel-with-memory-coalescing-enabled">Naive VecAdd kernel with memory coalescing enabled&lt;/h3>
&lt;p>The first program is simple but follows the coalescing memory access pattern:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>tid&lt;/th>
&lt;th>element&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&amp;hellip;&lt;/td>
&lt;td>&amp;hellip;&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The thread 0,1,2,3 visits elements 0,1,2,3, which is contiguous, and results in a coalescing memory accessing.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#007020;font-weight:bold">typename&lt;/span> T&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> add_coalesced0(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ a,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ b,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#666">*&lt;/span> __restrict__ c,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x &lt;span style="color:#666">+&lt;/span> threadIdx.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (i &lt;span style="color:#666">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c[i] &lt;span style="color:#666">=&lt;/span> a[i] &lt;span style="color:#666">+&lt;/span> b[i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The only issue is that, the number of the elements should be no larger than the number of threads, so the launching parameters of the kernel should be carefully designed.&lt;/p>
&lt;h3 id="optimized-one-strided-with-less-threads">Optimized one: strided with less threads&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#007020;font-weight:bold">typename&lt;/span> T&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> add_coalesced1(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ a,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ b,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#666">*&lt;/span> __restrict__ c,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> tid &lt;span style="color:#666">=&lt;/span> threadIdx.x &lt;span style="color:#666">+&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> num_threads &lt;span style="color:#666">=&lt;/span> blockDim.x &lt;span style="color:#666">*&lt;/span> gridDim.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">while&lt;/span> (tid &lt;span style="color:#666">&amp;lt;&lt;/span> N) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c[tid] &lt;span style="color:#666">=&lt;/span> a[tid] &lt;span style="color:#666">+&lt;/span> b[tid];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tid &lt;span style="color:#666">+=&lt;/span> num_threads;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This one simplifies the calculation of the launch thread number, it should fit any number of elements with a arbitrary number of threads.&lt;/p>
&lt;h3 id="uncoalesced-memory-accessing-one">Uncoalesced memory accessing one&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#007020;font-weight:bold">template&lt;/span> &lt;span style="color:#666">&amp;lt;&lt;/span>&lt;span style="color:#007020;font-weight:bold">typename&lt;/span> T&lt;span style="color:#666">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>__global__ &lt;span style="color:#902000">void&lt;/span> add_uncoalesced(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ a,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">const&lt;/span> T&lt;span style="color:#666">*&lt;/span> __restrict__ b,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#666">*&lt;/span> __restrict__ c,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> tid &lt;span style="color:#666">=&lt;/span> threadIdx.x &lt;span style="color:#666">+&lt;/span> blockIdx.x &lt;span style="color:#666">*&lt;/span> blockDim.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> num_threads &lt;span style="color:#666">=&lt;/span> blockDim.x &lt;span style="color:#666">*&lt;/span> gridDim.x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> num_tasks &lt;span style="color:#666">=&lt;/span> nvceil(n, num_threads);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">for&lt;/span> (&lt;span style="color:#902000">int&lt;/span> i &lt;span style="color:#666">=&lt;/span> &lt;span style="color:#40a070">0&lt;/span>; i &lt;span style="color:#666">&amp;lt;&lt;/span> num_tasks; &lt;span style="color:#666">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#902000">int&lt;/span> idx &lt;span style="color:#666">=&lt;/span> tid &lt;span style="color:#666">*&lt;/span> num_tasks &lt;span style="color:#666">+&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#007020;font-weight:bold">if&lt;/span> (idx &lt;span style="color:#666">&amp;lt;&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c[idx] &lt;span style="color:#666">=&lt;/span> a[idx] &lt;span style="color:#666">+&lt;/span> b[idx];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This one doesn&amp;rsquo;t follow the coalescing access pattern, lets assume that we have 4 threads with 8 elements, then the `num_tasks=2`&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>tid&lt;/th>
&lt;th>0-th element&lt;/th>
&lt;th>1-st element&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>2&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>4&lt;/td>
&lt;td>5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>6&lt;/td>
&lt;td>7&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>In the first step of the for-loop, these four threads visit 0,2,4,6 elements, which is not contiguous, this results in an uncoalesced memory accessing.&lt;/p>
&lt;h2 id="performance">Performance&lt;/h2>
&lt;p>All the kernels are tested with double data type, and the block size is 256, for the last kernels, each thread are setted to consume 8 elements.
The performance is tested on GTX 3090, with the clocks locked as below:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>GPU clocks&lt;/th>
&lt;th>Memory clocks&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>2100 MHZ&lt;/td>
&lt;td>9501MHZ&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The latency of each kernel:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>kernel&lt;/th>
&lt;th>latency&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>coalesced0&lt;/td>
&lt;td>0.04&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>coalesced1&lt;/td>
&lt;td>0.04&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>uncoalesced&lt;/td>
&lt;td>0.14&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>The uncoalesced kernel is 3x slower than the two coalesced kernel.&lt;/p>
&lt;p>The Nsight also report the Uncoalescing Global Accesses in the uncoalesced kernel:&lt;/p>
&lt;figure>&lt;img src="/ox-hugo/2024-02-28_19-37-47_screenshot.png">
&lt;/figure>
&lt;p>It reports that 75% of the sectors are excessive, IIUC, since only 8 bytes(a double) out each 32 byte transition is valid, so the overall efficiency is \(\frac{8}{32}=25\%\) .&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>Professional CUDA C Programming&lt;/li>
&lt;/ul></description></item></channel></rss>