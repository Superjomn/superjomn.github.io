<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Llvm on Superjomn's blog</title><link>/tags/llvm/</link><description>Recent content in Llvm on Superjomn's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 17 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="/tags/llvm/index.xml" rel="self" type="application/rss+xml"/><item><title>LLVM Utilities (keep updating)</title><link>/posts/llvm-utils/</link><pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate><guid>/posts/llvm-utils/</guid><description>&lt;p&gt;There are many handy functions or data structures in LLVM project, which are widely used by other projects that rely on LLVM. In this page, I will introduce some common utilities that are worthy of using in your own project or frequently used in LLVM code that you should be familiar with.&lt;/p&gt;
&lt;h2 id="basic-data-type"&gt;Basic data type&lt;/h2&gt;
&lt;h3 id="llvm-stringref"&gt;llvm::StringRef&lt;/h3&gt;
&lt;p&gt;It is a lightweight, non-owning reference to a sequence of characters.
It is similar to &lt;code&gt;std::string_view&lt;/code&gt; introduced in &lt;code&gt;C++17&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;// from a C-string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;&lt;/span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;const&lt;/span&gt; &lt;span style="color:#902000"&gt;char&lt;/span&gt;&lt;span style="color:#666"&gt;*&lt;/span&gt; cStr &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#4070a0"&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;StringRef strRef(cStr);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;// from a C++-string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;&lt;/span&gt;std&lt;span style="color:#666"&gt;::&lt;/span&gt;string cppStr &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#4070a0"&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;StringRef strRef1(cppStr);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;// from pointer and length
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;&lt;/span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;StringRef strRef2(cppStr.c_str(), cppStr.size());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="llvm-arrayref"&gt;llvm::ArrayRef&lt;/h3&gt;
&lt;p&gt;It is a lightweight, non-owning reference to an array of elements. It is similar to &lt;code&gt;std::span&lt;/code&gt; introduced in C++20.&lt;/p&gt;
&lt;p&gt;An example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#902000"&gt;int&lt;/span&gt; myArray[] &lt;span style="color:#666"&gt;=&lt;/span&gt; {&lt;span style="color:#40a070"&gt;1&lt;/span&gt;, &lt;span style="color:#40a070"&gt;2&lt;/span&gt;, &lt;span style="color:#40a070"&gt;3&lt;/span&gt;, &lt;span style="color:#40a070"&gt;4&lt;/span&gt;, &lt;span style="color:#40a070"&gt;5&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;ArrayRef&lt;span style="color:#666"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#902000"&gt;int&lt;/span&gt;&lt;span style="color:#666"&gt;&amp;gt;&lt;/span&gt; arrayRef(myArray, &lt;span style="color:#40a070"&gt;5&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="llvm-twine"&gt;llvm::Twine&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;llvm::Twine&lt;/code&gt; is a class used to efficiently concatenate strings in both memory and performance.&lt;/p&gt;
&lt;p&gt;To concate two strings:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;Twine twine1(&lt;span style="color:#4070a0"&gt;&amp;#34;Hello, &amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;Twine twine2(&lt;span style="color:#4070a0"&gt;&amp;#34;world!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;Twine result &lt;span style="color:#666"&gt;=&lt;/span&gt; twine1 &lt;span style="color:#666"&gt;+&lt;/span&gt; twine2;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To concate string with other elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;Twine twine1(&lt;span style="color:#4070a0"&gt;&amp;#34;The answer is &amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#902000"&gt;int&lt;/span&gt; value &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#40a070"&gt;42&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;Twine result &lt;span style="color:#666"&gt;=&lt;/span&gt; twine1 &lt;span style="color:#666"&gt;+&lt;/span&gt; llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;Twine(value);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is possible to concate multiple elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;Twine result &lt;span style="color:#666"&gt;=&lt;/span&gt; llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;Twine(&lt;span style="color:#4070a0"&gt;&amp;#34;Hello, &amp;#34;&lt;/span&gt;) &lt;span style="color:#666"&gt;+&lt;/span&gt; &lt;span style="color:#4070a0"&gt;&amp;#34;world!&amp;#34;&lt;/span&gt; &lt;span style="color:#666"&gt;+&lt;/span&gt; &lt;span style="color:#40a070"&gt;42&lt;/span&gt; &lt;span style="color:#666"&gt;+&lt;/span&gt; &lt;span style="color:#40a070"&gt;3.14&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the example above, the first &amp;ldquo;Hello&amp;rdquo; is a &lt;code&gt;Twine&lt;/code&gt; instance, and all the following &amp;ldquo;+&amp;rdquo; will use &lt;code&gt;Twine&lt;/code&gt;&amp;rsquo;s &lt;code&gt;operator+&lt;/code&gt; and get new &lt;code&gt;Twine&lt;/code&gt; instances, so it is able to concate any number of elements in the real usages.&lt;/p&gt;
&lt;h3 id="llvm-nullableptr"&gt;llvm::NullablePtr&lt;/h3&gt;
&lt;p&gt;It is used to represent a pointer that can be either a valid pointer or null.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;NullablePtr&lt;span style="color:#666"&gt;&amp;lt;&lt;/span&gt;MyType&lt;span style="color:#666"&gt;&amp;gt;&lt;/span&gt; ptr;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;ptr &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;new&lt;/span&gt; MyType();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;// or ptr = nullptr;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;if&lt;/span&gt; (ptr.isNull()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#60a0b0;font-style:italic"&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;&lt;/span&gt;} &lt;span style="color:#007020;font-weight:bold"&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;delete&lt;/span&gt; ptr.get(); &lt;span style="color:#60a0b0;font-style:italic"&gt;// get the underlying pointer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="container"&gt;Container&lt;/h2&gt;
&lt;h3 id="llvm-densemap"&gt;llvm::DenseMap&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;llvm::DenseMap&lt;/code&gt; has higher performance than &lt;code&gt;std::unordered_map&lt;/code&gt; and a similar usage.&lt;/p&gt;
&lt;p&gt;An example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;DenseMap&lt;span style="color:#666"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#902000"&gt;int&lt;/span&gt;, &lt;span style="color:#902000"&gt;float&lt;/span&gt;&lt;span style="color:#666"&gt;&amp;gt;&lt;/span&gt; map;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;map[&lt;span style="color:#40a070"&gt;20&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#40a070"&gt;20.f&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;map.insert(std&lt;span style="color:#666"&gt;::&lt;/span&gt;make_pair(&lt;span style="color:#40a070"&gt;20&lt;/span&gt;, &lt;span style="color:#40a070"&gt;20.f&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="llvm-densemapinfo"&gt;llvm::DenseMapInfo&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;llvm::DenseMapInfo&lt;/code&gt; is a utility class that provides information and hashing for custom types used as keys in &lt;code&gt;llvm::DenseMap&lt;/code&gt;. To use it, you should define your custom type with the following methods provided:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static KeyTy getEmptyKey()&lt;/code&gt;: This function should return a unique value representing an &amp;ldquo;empty&amp;rdquo; or &amp;ldquo;deleted&amp;rdquo; key in your custom type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static KeyTy getTombstoneKey()&lt;/code&gt;: It should return a unique value representing a &amp;ldquo;tombstone&amp;rdquo; key, which is used when a key is removed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static unique getHashValue(const KeyTy&amp;amp; key)&lt;/code&gt;: This function returns the hash value of a given key.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static bool isEqual(const KeyTy&amp;amp; a, const KeyTy &amp;amp;b)&lt;/code&gt;: This function compares two keys and returns true if they are equal, or false if they are not.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;struct&lt;/span&gt; &lt;span style="color:#0e84b5;font-weight:bold"&gt;MyKeyType&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#902000"&gt;int&lt;/span&gt; value;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;static&lt;/span&gt; MyKeyType &lt;span style="color:#06287e"&gt;getEmptyKey&lt;/span&gt;() { &lt;span style="color:#007020;font-weight:bold"&gt;return&lt;/span&gt; MyKeyType{&lt;span style="color:#666"&gt;-&lt;/span&gt;&lt;span style="color:#40a070"&gt;1&lt;/span&gt;}; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;static&lt;/span&gt; MyKeyType &lt;span style="color:#06287e"&gt;getTombstoneKey&lt;/span&gt;() { &lt;span style="color:#007020;font-weight:bold"&gt;return&lt;/span&gt; MyKeyType{&lt;span style="color:#666"&gt;-&lt;/span&gt;&lt;span style="color:#40a070"&gt;2&lt;/span&gt;}; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#902000"&gt;unsigned&lt;/span&gt; &lt;span style="color:#06287e"&gt;getHashValue&lt;/span&gt;(&lt;span style="color:#007020;font-weight:bold"&gt;const&lt;/span&gt; MyKeyType &lt;span style="color:#666"&gt;&amp;amp;&lt;/span&gt;key) { &lt;span style="color:#007020;font-weight:bold"&gt;return&lt;/span&gt; llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;hash_value(key.value); }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#902000"&gt;bool&lt;/span&gt; &lt;span style="color:#06287e"&gt;isEqual&lt;/span&gt;(&lt;span style="color:#007020;font-weight:bold"&gt;const&lt;/span&gt; MyKeyType &lt;span style="color:#666"&gt;&amp;amp;&lt;/span&gt;a, &lt;span style="color:#007020;font-weight:bold"&gt;const&lt;/span&gt; MyKeyType &lt;span style="color:#666"&gt;&amp;amp;&lt;/span&gt;b) { &lt;span style="color:#007020;font-weight:bold"&gt;return&lt;/span&gt; a.value &lt;span style="color:#666"&gt;==&lt;/span&gt; b.value; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After this, you should specialize the &lt;code&gt;llvm::DenseMapInfo&lt;/code&gt; template for your custom type:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;namespace&lt;/span&gt; llvm {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;template&lt;/span&gt; &lt;span style="color:#666"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;struct&lt;/span&gt; &lt;span style="color:#0e84b5;font-weight:bold"&gt;DenseMapInfo&lt;/span&gt;&lt;span style="color:#666"&gt;&amp;lt;&lt;/span&gt;MyKeyType&lt;span style="color:#666"&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;static&lt;/span&gt; MyKeyType &lt;span style="color:#06287e"&gt;getEmptyKey&lt;/span&gt;() { &lt;span style="color:#007020;font-weight:bold"&gt;return&lt;/span&gt; MyKeyType&lt;span style="color:#666"&gt;::&lt;/span&gt;getEmptyKey(); }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;static&lt;/span&gt; MyKeyType &lt;span style="color:#06287e"&gt;getTombstoneKey&lt;/span&gt;() { &lt;span style="color:#007020;font-weight:bold"&gt;return&lt;/span&gt; MyKeyType&lt;span style="color:#666"&gt;::&lt;/span&gt;getTombstoneKey(); }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#902000"&gt;unsigned&lt;/span&gt; &lt;span style="color:#06287e"&gt;getHashValue&lt;/span&gt;(&lt;span style="color:#007020;font-weight:bold"&gt;const&lt;/span&gt; MyKeyType &lt;span style="color:#666"&gt;&amp;amp;&lt;/span&gt;key) { &lt;span style="color:#007020;font-weight:bold"&gt;return&lt;/span&gt; MyKeyType&lt;span style="color:#666"&gt;::&lt;/span&gt;getHashValue(key); }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#902000"&gt;bool&lt;/span&gt; &lt;span style="color:#06287e"&gt;isEqual&lt;/span&gt;(&lt;span style="color:#007020;font-weight:bold"&gt;const&lt;/span&gt; MyKeyType &lt;span style="color:#666"&gt;&amp;amp;&lt;/span&gt;a, &lt;span style="color:#007020;font-weight:bold"&gt;const&lt;/span&gt; MyKeyType &lt;span style="color:#666"&gt;&amp;amp;&lt;/span&gt;b) { &lt;span style="color:#007020;font-weight:bold"&gt;return&lt;/span&gt; MyKeyType&lt;span style="color:#666"&gt;::&lt;/span&gt;isEqual(a, b); }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="llvm-stringmap"&gt;llvm::StringMap&lt;/h3&gt;
&lt;p&gt;It is a map-like container that is specially optimized for string keys.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;StringMap&lt;span style="color:#666"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#902000"&gt;int&lt;/span&gt;&lt;span style="color:#666"&gt;&amp;gt;&lt;/span&gt; stringToIntMap;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;stringToIntMap[&lt;span style="color:#4070a0"&gt;&amp;#34;name&amp;#34;&lt;/span&gt;] &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#4070a0"&gt;&amp;#34;Tim&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;stringToIntMap.insert(std&lt;span style="color:#666"&gt;::&lt;/span&gt;map_pair(&lt;span style="color:#4070a0"&gt;&amp;#34;name&amp;#34;&lt;/span&gt;, &lt;span style="color:#4070a0"&gt;&amp;#34;Tom&amp;#34;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="llvm-smallvector"&gt;llvm::SmallVector&lt;/h3&gt;
&lt;p&gt;It is a dynamic array container that quite similar to &lt;code&gt;std::vector&lt;/code&gt; but optimized for situations where the number of elements is expected to be small.&lt;/p&gt;
&lt;p&gt;An example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;SmallVector&lt;span style="color:#666"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#902000"&gt;int&lt;/span&gt;, &lt;span style="color:#40a070"&gt;4&lt;/span&gt;&lt;span style="color:#666"&gt;&amp;gt;&lt;/span&gt; vec;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;vec.push_back(&lt;span style="color:#40a070"&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="misc"&gt;Misc&lt;/h2&gt;
&lt;h3 id="llvm-bumpptrallocator"&gt;llvm::BumpPtrAllocator&lt;/h3&gt;
&lt;p&gt;This is an allocator used to allocate memory in a highly efficient manner. But note that, it doesn&amp;rsquo;t support deallocation for the elements allocated.
Once the &lt;code&gt;llvm::BumpPtrAllocator&lt;/code&gt; instance is freed, all the allocated elements will be deallocated in bulk automatically.&lt;/p&gt;
&lt;p&gt;An example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-C++" data-lang="C++"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;llvm&lt;span style="color:#666"&gt;::&lt;/span&gt;BumpPtrAllocator allocator;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#902000"&gt;int&lt;/span&gt;&lt;span style="color:#666"&gt;*&lt;/span&gt; intPtr &lt;span style="color:#666"&gt;=&lt;/span&gt; allocator.Allocate&lt;span style="color:#666"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#902000"&gt;int&lt;/span&gt;&lt;span style="color:#666"&gt;&amp;gt;&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;*&lt;/span&gt;intPtr &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#40a070"&gt;100&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="updating-log"&gt;Updating log&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;[2024-02-25 Sun] &lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; Publish the post&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>