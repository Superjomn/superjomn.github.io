<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lisp on Superjomn's blog</title><link>/tags/lisp/</link><description>Recent content in Lisp on Superjomn's blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 28 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="/tags/lisp/index.xml" rel="self" type="application/rss+xml"/><item><title>Emacs Lisp Introduction for Python Programmers</title><link>/posts/elisp-tutorial-for-pythoner/</link><pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate><guid>/posts/elisp-tutorial-for-pythoner/</guid><description>&lt;p&gt;This is a brief introduction to Emacs Lisp for Python programmers, (although I am not an Elisp expert, and actually I am more familiar with Python than Elisp). Both languages have quite different syntaxes, it is interesting to see how can implement Python code with lisp code.&lt;/p&gt;
&lt;p&gt;The content follows the strucutre from &lt;a href="https://learnxinyminutes.com/docs/python/"&gt;Learn X in Y Minutes Where X is Python&lt;/a&gt;, and we will touch all the topics.&lt;/p&gt;
&lt;h2 id="primitive-datatypes-and-operators"&gt;Primitive Datatypes and Operators&lt;/h2&gt;
&lt;h3 id="numbers"&gt;Numbers&lt;/h3&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;b&gt;Python&lt;/b&gt;
&lt;pre&gt;&lt;code class="python-html"&gt;
# Integer
1
# Float
3.14
# Math is what you would expect
1 + 1 # =&gt; 2
8 - 1 # =&gt; 7
10 * 2 # =&gt; 20
35 / 5 # =&gt; 7.0
# Integer division rounds down for both positive and negative numbers.
5 // 3 # =&gt; 1
-5 // 3 # =&gt; -2
5.0 // 3.0 # =&gt; 1.0 # works on floats too
-5.0 // 3.0 # =&gt; -2.0
# The result of division is always a float
10.0 / 3 # =&gt; 3.3333333333333335
# Modulo operation
7 % 3 # =&gt; 1
# i % j have the same sign as j, unlike C
-7 % 3 # =&gt; 2
# Exponentiation (x**y, x to the yth power)
2**3 # =&gt; 8
# Enforce precedence with parentheses
1 + 3 * 2 # =&gt; 7
(1 + 3) * 2 # =&gt; 8
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;b&gt;Elisp&lt;/b&gt;
&lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Integer
1
;; Float
3.14
;; Math is what you would expect
(+ 1 1) ; =&gt; 2
(- 8 1) ; =&gt; 7
(* 10 2) ; =&gt; 20
(/ 35 5) ; =&gt; 7
;; Integer division rounds down for both positive and negative numbers.
(truncate (/ 5 3)) ; =&gt; 1
(truncate (/ -5 3)) ; =&gt; -2
(truncate (/ 5.0 3.0)) ; =&gt; 1.0 ; works on floats too
(truncate (/ -5.0 3.0)) ; =&gt; -2.0
;; The result of division is always a float if the denominator or numerator is float
(/ 10.0 3) ; =&gt; 3.3333333333333335
;; Modulo operation
(% 7 3) ; =&gt; 1
;; different from Python
(% -7 3) ; =&gt; -1
;; Exponentiation
(expt 2 3) ; =&gt; 8
;; Enforce precedence with parentheses
(+ 1 (* 3 2)) ; =&gt; 7
(* (1+ 3) 2) ; =&gt; 8
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;/table&gt;
&lt;h3 id="bools-and-comparasion"&gt;Bools and comparasion&lt;/h3&gt;
&lt;p&gt;In Emacs Lisp, booleans are represented by the symbols &lt;code&gt;t&lt;/code&gt; for true and &lt;code&gt;nil&lt;/code&gt; for false.&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt; &lt;td&gt;
&lt;pre&gt;&lt;code class="python-html"&gt;
# Boolean values are primitives (Note: the capitalization)
True # =&gt; True
False # =&gt; False
# negate with not
not True # =&gt; False
not False # =&gt; True
# Boolean Operators
# Note "and" and "or" are case-sensitive
True and False # =&gt; False
False or True # =&gt; True
# True and False are actually 1 and 0 but with different keywords
True + True # =&gt; 2
True * 8 # =&gt; 8
False - 5 # =&gt; -5
# Comparison operators look at the numerical value of True and False
0 == False # =&gt; True
2 &gt; True # =&gt; True
2 == True # =&gt; False
-5 != False # =&gt; True
# None, 0, and empty strings/lists/dicts/tuples/sets all evaluate to False.
# All other values are True
bool(0) # =&gt; False
bool("") # =&gt; False
bool([]) # =&gt; False
bool({}) # =&gt; False
bool(()) # =&gt; False
bool(set()) # =&gt; False
bool(4) # =&gt; True
bool(-6) # =&gt; True
bool(0) # =&gt; False
bool(2) # =&gt; True
0 and 2 # =&gt; 0
bool(-5) # =&gt; True
bool(2) # =&gt; True
-5 or 0 # =&gt; -5
# Equality is ==
1 == 1 # =&gt; True
2 == 1 # =&gt; False
# Inequality is !=
1 != 1 # =&gt; False
2 != 1 # =&gt; True
# More comparisons
1 &lt; 10 # =&gt; True
1 &gt; 10 # =&gt; False
2 &lt;= 2 # =&gt; True
2 &gt;= 2 # =&gt; True
# Seeing whether a value is in a range
1 &lt; 2 and 2 &lt; 3 # =&gt; True
2 &lt; 3 and 3 &lt; 2 # =&gt; False
# Chaining makes this look nicer
1 &lt; 2 &lt; 3 # =&gt; True
2 &lt; 3 &lt; 2 # =&gt; False
# (is vs. ==) is checks if two variables refer to the same object, but == checks
# if the objects pointed to have the same values.
a = [1, 2, 3, 4] # Point a at a new list, [1, 2, 3, 4]
b = a # Point b at what a is pointing to
b is a # =&gt; True, a and b refer to the same object
b == a # =&gt; True, a's and b's objects are equal
b = [1, 2, 3, 4] # Point b at a new list, [1, 2, 3, 4]
b is a # =&gt; False, a and b do not refer to the same object
b == a # =&gt; True, a's and b's objects are equal
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Boolean values are symbols
t ; =&gt; t
nil ; =&gt; nil
;; negate with not
(not t) ; =&gt; nil
(not nil) ; =&gt; t
;; Boolean Operators
;; Use `and` and `or` for logical operations
(and t nil) ; =&gt; nil
(or nil t) ; =&gt; t
;; In Elisp, `t` or `nil` is not numeric, so numerical operations will fail
(+ t t) ; error
(* t 8) ; error
(- nil 5) ; error
;; Comparison operators
(= 0 nil) ; =&gt; error, since nil is not a numerical value
(eq 0 nil) ; =&gt; nil, because `eq` is used for checking equality of objects
; similar to Python's `is`
(eq 1.0 1.0) ; =&gt; nil, both are different objects
(= 1.0 1.0) ; =&gt; t, numerical equal
(eq 1 1) ; =&gt; t, constant integers of same value share the same object
;; In Elisp, `nil` is the only false value. All other values are true.
(not 0) ; =&gt; nil
(not "") ; =&gt; nil
(not '()) ; =&gt; nil
(not (make-hash-table)) ; =&gt; nil
(not nil) ; =&gt; t
(not 4) ; =&gt; nil
(not -6) ; =&gt; nil
(and nil 2) ; =&gt; nil
(or -5 nil) ; =&gt; -5
;; Equality is checked with `eq` for objects
;; and `equal` for value comparison, or `=` for numbers
(= 1 1) ; =&gt; t
(= 2 1) ; =&gt; nil
;; Inequality with `/=`
(/= 1 1) ; =&gt; nil
(/= 2 1) ; =&gt; t
;; More comparisons
(&lt; 1 10) ; =&gt; t
(&gt; 1 10) ; =&gt; nil
(&lt;= 2 2) ; =&gt; t
(&gt;= 2 2) ; =&gt; t
;; Logical combinations for range checking
;; Chaining like Python's `1 &lt; 2 &lt; 3` doesn't directly translate
(and (&lt; 1 2) (&lt; 2 3)) ; =&gt; t
(and (&lt; 2 3) (&lt; 3 2)) ; =&gt; nil
;; Setting up variables and lists
(setq a '(1 2 3 4)) ; Set 'a' to a new list
(setq b a) ; Point 'b' at what 'a' is pointing to
(eq b a) ; =&gt; t, 'a' and 'b' refer to the same object
(equal b a) ; =&gt; t, 'a's and 'b's objects are equal
(setq b '(1 2 3 4)) ; Set 'b' to a new, but identical list
(eq b a) ; =&gt; nil, 'a' and 'b' do not refer to the same object
(equal b a) ; =&gt; t, 'a's and 'b's objects are equal
&lt;/code&gt;&lt;/pre&gt;
&lt;/td&gt; &lt;/tr&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;eq&lt;/code&gt; checks if two symbols or objects refer to the same memory address (identical objects).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;equal&lt;/code&gt; tests for structural equality without considering if the two are the exact same object.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="string-related"&gt;String related&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Strings are created with " or '
"This is a string."
'This is also a string.'
# Strings can be added too
"Hello " + "world!" # =&gt; "Hello world!"
# String literals (but not variables) can be concatenated without using '+'
"Hello " "world!" # =&gt; "Hello world!"
# A string can be treated like a list of characters
"Hello world!"[0] # =&gt; 'H'
# You can find the length of a string
len("This is a string") # =&gt; 16
# Since Python 3.6, you can use f-strings or formatted string literals.
name = "Reiko"
f"She said her name is {name}." # =&gt; "She said her name is Reiko"
# Any valid Python expression inside these braces is returned to the string.
f"{name} is {len(name)} characters long." # =&gt; "Reiko is 5 characters long."
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Strings are created with double quotes
"This is a string."
"This is also a string."
;; Strings can be concatenated using `concat`
(concat "Hello " "world!") ; =&gt; "Hello world!"
;; In Elisp, there is no automatic concatenation without using a function like `concat`.
;; Accessing a character in a string
(aref "Hello world!" 0) ; =&gt; 72 (returns the ASCII value of 'H')
;; You can convert the ASCII value to a character if needed
(char-to-string (aref "Hello world!" 0)) ; =&gt; "H"
;; Finding the length of a string
(length "This is a string") ; =&gt; 16
;; Emacs Lisp doesn't have a built-in feature exactly like Python's f-strings,
;; but you can use `format` to achieve similar results.
(setq name "Reiko")
(format "She said her name is %s." name) ; =&gt; "She said her name is Reiko."
;; Using `format` for more complex expressions
(format "%s is %d characters long." name (length name)) ; =&gt; "Reiko is 5 characters long."
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h3 id="variables-and-collections"&gt;Variables and Collections&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="language-python"&gt;
print("I'm Python. Nice to meet you!") # =&gt; I'm Python. Nice to meet you!
# By default the print function also prints out a newline at the end.
# Use the optional argument end to change the end string.
print("Hello, World", end="!") # =&gt; Hello, World!
# Simple way to get input data from console
input_string_var = input("Enter some data: ") # Returns the data as a string
# There are no declarations, only assignments.
# Convention in naming variables is snake_case style
some_var = 5
some_var # =&gt; 5
# Accessing a previously unassigned variable is an exception.
# See Control Flow to learn more about exception handling.
some_unknown_var # Raises a NameError
# if can be used as an expression
# Equivalent of C's '?:' ternary operator
"yay!" if 0 &gt; 1 else "nay!" # =&gt; "nay!"
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Emacs Lisp has a print function, `message`, commonly used for displaying output in the echo area.
(message "I'm Emacs Lisp. Nice to meet you!") ; Prints: I'm Emacs Lisp. Nice to meet you!
;; By default, `message` also outputs a newline at the end. You can concatenate strings to simulate different endings.
(message "Hello, World!") ; Prints: Hello, World
;; Simple way to get input data from console
(setq input-string-var (read-string "Enter some data: ")) ; Prompts user and returns the data as a string
;; Variables are set with `setq`, and Emacs Lisp uses lower-case with dashes (lisp-case).
(setq some-var 5)
some-var ; =&gt; 5
;; Accessing a previously unassigned variable results in `nil` if not set, not an exception.
some-unknown-var ; =&gt; nil unless previously set, does not raise an error
;; `if` can be used similarly to the ternary operator
(if (&gt; 0 1) "yay!" "nay!") ; =&gt; "nay!"
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h4 id="list"&gt;list&lt;/h4&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Lists store sequences
li = []
# You can start with a prefilled list
other_li = [4, 5, 6]
# Add stuff to the end of a list with append
li.append(1) # li is now [1]
li.append(2) # li is now [1, 2]
li.append(4) # li is now [1, 2, 4]
li.append(3) # li is now [1, 2, 4, 3]
# Remove from the end with pop
li.pop() # =&gt; 3 and li is now [1, 2, 4]
# Let's put it back
li.append(3) # li is now [1, 2, 4, 3] again.
# Access a list like you would any array
li[0] # =&gt; 1
# Look at the last element
li[-1] # =&gt; 3
# Looking out of bounds is an IndexError
li[4] # Raises an IndexError
# Make a one layer deep copy using slices
li2 = li[:] # =&gt; li2 = [1, 2, 4, 3] but (li2 is li) will result in false.
# Remove arbitrary elements from a list with "del"
del li[2] # li is now [1, 2, 3]
# Remove first occurrence of a value
li.remove(2) # li is now [1, 3]
li.remove(2) # Raises a ValueError as 2 is not in the list
# Insert an element at a specific index
li.insert(1, 2) # li is now [1, 2, 3] again
# Get the index of the first item found matching the argument
li.index(2) # =&gt; 1
li.index(4) # Raises a ValueError as 4 is not in the list
# You can add lists
# Note: values for li and for other_li are not modified.
li + other_li # =&gt; [1, 2, 3, 4, 5, 6]
# Concatenate lists with "extend()"
li.extend(other_li) # Now li is [1, 2, 3, 4, 5, 6]
# Check for existence in a list with "in"
1 in li # =&gt; True
# Examine the length with "len()"
len(li) # =&gt; 6
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Lists store sequences
(setq li '())
;; You can start with a prefilled list
(setq other-li '(4 5 6))
;; The '(...) is a macro of (list ...), so the below has same effect
(setq other-li (list 4 5 6))
;; Add stuff to the end of a list with `push` (note: `push` adds to the front, so let's use `append` for the end)
(setq li (append li '(1))) ; li is now (1)
(setq li (append li '(2))) ; li is now (1 2)
(setq li (append li '(4))) ; li is now (1 2 4)
(setq li (append li '(3))) ; li is now (1 2 4 3)
;; Remove from the end with `pop`
(pop li) ; =&gt; 3 and li is now (1 2 4)
;; Let's put it back
(setq li (append li '(3))) ; li is now (1 2 4 3) again.
;; Access a list like you would any array (using `nth`)
(nth 0 li) ; =&gt; 1
;; Look at the last element (using `car` on the reversed list)
(car (last li)) ; =&gt; 3
;; Looking out of bounds does not raise an error by default, returns nil
(nth 4 li) ; =&gt; nil, does not raise an IndexError
;; Make a one layer deep copy using `copy-sequence`
(setq li2 (copy-sequence li)) ;; li2 equals [1 2 4 3] but (eq li2 li) will result in nil.
;; Remove arbitrary elements from a list with `setf` and `nthcdr`
(setf (nthcdr 2 li) (cddr (nthcdr 2 li))) ;; li is now [1 2 3]
;; Emacs Lisp does not have a direct equivalent of Python's `list.remove`
;; for non-destructive removal, you'd typically filter the list
(setq li (remove 2 li)) ;; li is now [1 3]
;; For handling error (when element is not in the list), Emacs Lisp usually uses `condition-case`
(condition-case nil
(setq li (remove 2 li))
(error (message "ValueError: 2 is not in the list")))
;; Insert an element at a specific index
(setq li (cl-list* 1 2 (cdr li))) ;; li is now [1 2 3] again, using `cl-list*` to splice
;; Get the index of the first item found matching the argument
(position 2 li) ;; =&gt; 1
(condition-case nil
(position 4 li)
(error (message "ValueError: 4 is not in the list")))
;; You can add lists
(setq result (append li other_li)) ;; =&gt; [1 2 3 4 5 6]
;; Concatenate lists with `append` (destructively with `nconc`)
(setq li (append li other_li)) ;; Now li is [1 2 3 4 5 6]
;; Check for existence in a list with `member`
(member 1 li) ;; =&gt; (1 2 3 4 5 6) which is true-ish in Lisp (non-nil means true)
;; Examine the length with `length`
(length li) ;; =&gt; 6
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h4 id="dict"&gt;Dict&lt;/h4&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Dictionaries store mappings from keys to values
empty_dict = {}
# Here is a prefilled dictionary
filled_dict = {"one": 1, "two": 2, "three": 3}
# Note keys for dictionaries have to be immutable types. This is to ensure that
# the key can be converted to a constant hash value for quick look-ups.
# Immutable types include ints, floats, strings, tuples.
invalid_dict = {[1,2,3]: "123"} # =&gt; Yield a TypeError: unhashable type: 'list'
valid_dict = {(1,2,3):[1,2,3]} # Values can be of any type, however.
# Look up values with []
filled_dict["one"] # =&gt; 1
# Get all keys as an iterable with "keys()". We need to wrap the call in list()
# to turn it into a list. We'll talk about those later. Note - for Python
# versions &lt;3.7, dictionary key ordering is not guaranteed. Your results might
# not match the example below exactly. However, as of Python 3.7, dictionary
# items maintain the order at which they are inserted into the dictionary.
list(filled_dict.keys()) # =&gt; ["three", "two", "one"] in Python &lt;3.7
list(filled_dict.keys()) # =&gt; ["one", "two", "three"] in Python 3.7+
# Get all values as an iterable with "values()". Once again we need to wrap it
# in list() to get it out of the iterable. Note - Same as above regarding key
# ordering.
list(filled_dict.values()) # =&gt; [3, 2, 1] in Python &lt;3.7
list(filled_dict.values()) # =&gt; [1, 2, 3] in Python 3.7+
# Check for existence of keys in a dictionary with "in"
"one" in filled_dict # =&gt; True
1 in filled_dict # =&gt; False
# Looking up a non-existing key is a KeyError
filled_dict["four"] # KeyError
# Use "get()" method to avoid the KeyError
filled_dict.get("one") # =&gt; 1
filled_dict.get("four") # =&gt; None
# The get method supports a default argument when the value is missing
filled_dict.get("one", 4) # =&gt; 1
filled_dict.get("four", 4) # =&gt; 4
# "setdefault()" inserts into a dictionary only if the given key isn't present
filled_dict.setdefault("five", 5) # filled_dict["five"] is set to 5
filled_dict.setdefault("five", 6) # filled_dict["five"] is still 5
# Adding to a dictionary
filled_dict.update({"four":4}) # =&gt; {"one": 1, "two": 2, "three": 3, "four": 4}
filled_dict["four"] = 4 # another way to add to dict
# Remove keys from a dictionary with del
del filled_dict["one"] # Removes the key "one" from filled dict
# From Python 3.5 you can also use the additional unpacking options
{"a": 1, **{"b": 2}} # =&gt; {'a': 1, 'b': 2}
{"a": 1, **{"a": 2}} # =&gt; {'a': 2}
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Hash tables store mappings from keys to values
(setq empty-dict (make-hash-table))
;; Here is a prefilled hash table
(setq filled-dict (make-hash-table :test 'equal))
(puthash "one" 1 filled-dict)
(puthash "two" 2 filled-dict)
(puthash "three" 3 filled-dict)
;; Note keys for hash tables should be comparable with the test function, `equal` here allows strings
;; Emacs Lisp hash tables do not restrict key types as strictly as Python does by default.
;; Attempt to use mutable types such as lists can be handled but requires careful consideration of equality testing.
;; Look up values with `gethash`
(gethash "one" filled-dict) ;; =&gt; 1
;; Get all keys as a list
(hash-table-keys filled-dict) ;; =&gt; '("one" "two" "three") in Emacs Lisp, ordering depends on hash function
;; Get all values as a list
(hash-table-values filled-dict) ;; =&gt; '(1 2 3)
;; Check for existence of keys in a hash table with `gethash`
(when (gethash "one" filled-dict) t) ;; =&gt; t (true)
(when (gethash 1 filled-dict) t) ;; =&gt; nil (false)
;; Looking up a non-existing key returns nil by default, no error
(gethash "four" filled-dict) ;; =&gt; nil
;; Use `gethash` with a default value to avoid nil for non-existing keys
(gethash "one" filled-dict 4) ;; =&gt; 1
(gethash "four" filled-dict 4) ;; =&gt; 4
;; `sethash` inserts into a hash table, replacing any existing value for the key
(puthash "five" 5 filled-dict) ;; filled-dict now has key "five" set to 5
(puthash "five" 6 filled-dict) ;; filled-dict["five"] is updated to 6
;; Adding to a hash table
(puthash "four" 4 filled-dict) ;; filled-dict now includes "four" =&gt; 4
;; Remove keys from a hash table with `remhash`
(remhash "one" filled-dict) ;; Removes the key "one" from filled-dict
;; Unpacking and merging hash tables isn't a direct feature in Emacs Lisp,
;; but can be achieved through looping and setting keys.
;; Below is an example of how to "merge" two hash tables in Emacs Lisp.
(setq a (make-hash-table :test 'equal))
(setq b (make-hash-table :test 'equal))
(puthash "a" 1 a)
(puthash "b" 2 b)
;; Simulating Python's dict unpacking:
(maphash (lambda (k v) (puthash k v a)) b)
;; Now, 'a' contains the contents of both 'a' and 'b'
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h4 id="set"&gt;Set&lt;/h4&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Sets store ... well sets
empty_set = set()
# Initialize a set with a bunch of values.
some_set = {1, 1, 2, 2, 3, 4} # some_set is now {1, 2, 3, 4}
# Similar to keys of a dictionary, elements of a set have to be immutable.
invalid_set = {[1], 1} # =&gt; Raises a TypeError: unhashable type: 'list'
valid_set = {(1,), 1}
# Add one more item to the set
filled_set = some_set
filled_set.add(5) # filled_set is now {1, 2, 3, 4, 5}
# Sets do not have duplicate elements
filled_set.add(5) # it remains as before {1, 2, 3, 4, 5}
# Do set intersection with &amp;
other_set = {3, 4, 5, 6}
filled_set &amp; other_set # =&gt; {3, 4, 5}
# Do set union with |
filled_set | other_set # =&gt; {1, 2, 3, 4, 5, 6}
# Do set difference with -
{1, 2, 3, 4} - {2, 3, 5} # =&gt; {1, 4}
# Do set symmetric difference with ^
{1, 2, 3, 4} ^ {2, 3, 5} # =&gt; {1, 4, 5}
# Check if set on the left is a superset of set on the right
{1, 2} &gt;= {1, 2, 3} # =&gt; False
# Check if set on the left is a subset of set on the right
{1, 2} &lt;= {1, 2, 3} # =&gt; True
# Check for existence in a set with in
2 in filled_set # =&gt; True
10 in filled_set # =&gt; False
# Make a one layer deep copy
filled_set = some_set.copy() # filled_set is {1, 2, 3, 4, 5}
filled_set is some_set # =&gt; False
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Sets store ... well, something akin to sets using hash tables
(setq empty-set (make-hash-table :test 'equal))
;; Initialize a "set" with a bunch of values
(setq some-set (make-hash-table :test 'equal))
(mapc (lambda (x) (puthash x t some-set)) '(1 1 2 2 3 4)) ;; some-set is now effectively {1, 2, 3, 4}
;; Similar to keys of a dictionary, elements of a "set" have to be comparable with the test function.
;; Invalid "set" construction would cause errors if attempted with non-hashable types.
;; This is an invalid line in Emacs Lisp and commented out:
;; (setq invalid-set (make-hash-table :test 'equal))
;; (puthash [1] t invalid-set) ;; Would raise an error in a hypothetical correct context
(setq valid-set (make-hash-table :test 'equal))
(puthash (list 1) t valid-set)
(puthash 1 t valid-set)
;; Add one more item to the "set"
(setq filled-set some-set)
(puthash 5 t filled-set) ;; filled-set is now effectively {1, 2, 3, 4, 5}
(puthash 5 t filled-set) ;; it remains as before {1, 2, 3, 4, 5}
;; Set operations using hash tables require custom functions or cl-lib utilities:
;; Intersection (set1 &amp; set2)
(setq other-set (make-hash-table :test 'equal))
(mapc (lambda (x) (puthash x t other-set)) '(3 4 5 6))
(setq intersection-set (cl-intersection (hash-table-keys filled-set) (hash-table-keys other-set) :test 'equal))
;; Union (set1 | set2)
(setq union-set (cl-union (hash-table-keys filled-set) (hash-table-keys other-set) :test 'equal))
;; Difference (set1 - set2)
(setq difference-set (cl-set-difference (hash-table-keys filled-set) (hash-table-keys other-set) :test 'equal))
;; Symmetric Difference (set1 ^ set2)
(setq symmetric-difference-set (cl-set-exclusive-or (hash-table-keys filled-set) (hash-table-keys other-set) :test 'equal))
;; Superset check
(cl-subsetp (hash-table-keys other-set) (hash-table-keys filled-set) :test 'equal) ;; =&gt; nil (false, filled-set is not a superset)
;; Subset check
(cl-subsetp (hash-table-keys '(1 2)) (hash-table-keys '(1 2 3)) :test 'equal) ;; =&gt; t (true, {1, 2} is a subset of {1, 2, 3})
;; Check for existence in a "set" with `gethash`
(gethash 2 filled-set) ;; =&gt; t (true)
(gethash 10 filled-set) ;; =&gt; nil (false)
;; Make a one layer deep copy
(setq filled-set-copy (make-hash-table :test 'equal))
(maphash (lambda (k v) (puthash k v filled-set-copy)) filled-set)
(eq filled-set filled-set-copy) ;; =&gt; nil
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h2 id="control-flow-and-iterables"&gt;Control Flow and Iterables&lt;/h2&gt;
&lt;h3 id="if"&gt;if&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Let's just make a variable
some_var = 5
# Here is an if statement. Indentation is significant in Python!
# Convention is to use four spaces, not tabs.
# This prints "some_var is smaller than 10"
if some_var &gt; 10:
print("some_var is totally bigger than 10.")
elif some_var &lt; 10: # This elif clause is optional.
print("some_var is smaller than 10.")
else: # This is optional too.
print("some_var is indeed 10.")
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Let's just make a variable
(setq some-var 5)
;; Here is an if statement
;; This prints "some_var is smaller than 10"
(if (&gt; some-var 10)
(message "some_var is totally bigger than 10.")
(if (&lt; some-var 10) ;; This is like the elif in Python
(message "some_var is smaller than 10.")
(message "some_var is indeed 10."))) ;; This is the else part
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
"""
For loops iterate over lists
prints:
dog is a mammal
cat is a mammal
mouse is a mammal
"""
for animal in ["dog", "cat", "mouse"]:
# You can use format() to interpolate formatted strings
print("{} is a mammal".format(animal))
"""
"range(number)" returns an iterable of numbers
from zero up to (but excluding) the given number
prints:
0
1
2
3
"""
for i in range(4):
print(i)
"""
"range(lower, upper)" returns an iterable of numbers
from the lower number to the upper number
prints:
4
5
6
7
"""
for i in range(4, 8):
print(i)
"""
"range(lower, upper, step)" returns an iterable of numbers
from the lower number to the upper number, while incrementing
by step. If step is not indicated, the default value is 1.
prints:
4
6
"""
for i in range(4, 8, 2):
print(i)
"""
Loop over a list to retrieve both the index and the value of each list item:
0 dog
1 cat
2 mouse
"""
animals = ["dog", "cat", "mouse"]
for i, value in enumerate(animals):
print(i, value)
"""
While loops go until a condition is no longer met.
prints:
0
1
2
3
"""
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; For loops iterate over lists
(dolist (animal '("dog" "cat" "mouse"))
;; You can use `format` to interpolate formatted strings
(message "%s is a mammal" animal))
;; "dotimes" is used to iterate over a sequence of numbers
(dotimes (i 4)
(message "%d" i))
;; To create a range from 4 to 7 (inclusive in Python, but we adjust for Lisp)
(dotimes (i 4)
(message "%d" (+ i 4)))
;; Range with a step
(let ((start 4)
(end 8)
(step 2))
(while (&lt; start end)
(message "%d" start)
(setq start (+ start step))))
;; Loop over a list to retrieve both the index and the value of each list item
(let ((animals '("dog" "cat" "mouse"))
(i 0))
(dolist (value animals)
(message "%d %s" i value)
(setq i (1+ i))))
;; While loops go until a condition is no longer met.
(let ((i 0))
(while (&lt; i 4)
(message "%d" i)
(setq i (1+ i))))
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h3 id="while"&gt;While&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
"""
While loops go until a condition is no longer met.
prints:
0
1
2
3
"""
x = 0
while x &lt; 4:
print(x)
x += 1 # Shorthand for x = x + 1
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; For loops iterate over lists
(dolist (animal '("dog" "cat" "mouse"))
;; You can use `format` to interpolate formatted strings
(message "%s is a mammal" animal))
;; "dotimes" is used to iterate over a sequence of numbers
(dotimes (i 4)
(message "%d" i))
;; To create a range from 4 to 7 (inclusive in Python, but we adjust for Lisp)
(dotimes (i 4)
(message "%d" (+ i 4)))
;; Range with a step
(let ((start 4)
(end 8)
(step 2))
(while (&lt; start end)
(message "%d" start)
(setq start (+ start step))))
;; Loop over a list to retrieve both the index and the value of each list item
(let ((animals '("dog" "cat" "mouse"))
(i 0))
(dolist (value animals)
(message "%d %s" i value)
(setq i (1+ i))))
;; While loops go until a condition is no longer met.
(let ((i 0))
(while (&lt; i 4)
(message "%d" i)
(setq i (1+ i))))
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h3 id="try-dot-dot-dot-catch"&gt;try &amp;hellip; catch&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Handle exceptions with a try/except block
try:
# Use "raise" to raise an error
raise IndexError("This is an index error")
except IndexError as e:
pass # Refrain from this, provide a recovery (next example).
except (TypeError, NameError):
pass # Multiple exceptions can be processed jointly.
else: # Optional clause to the try/except block. Must follow
# all except blocks.
print("All good!") # Runs only if the code in try raises no exceptions
finally: # Execute under all circumstances
print("We can clean up resources here")
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Handle exceptions with a condition-case
(condition-case err
;; Use `error` to raise an error
(error "This is an index error")
;; Each error type to be caught is specified in a separate clause.
(error (message "Caught an error: %s" (error-message-string err))) ;; Handle specific errors
(index-error nil) ;; No action taken, similar to 'pass' in Python
(type-error nil)) ;; Handle multiple specific errors jointly like TypeError
;; Emacs Lisp does not have a direct equivalent of Python's else and finally clauses.
;; To simulate 'finally', you just continue writing code after the condition-case
(message "We can clean up resources here")
;; If you need to run something only if no error was raised, you would have to manage
;; it with additional flags or control flow structures outside the condition-case.
(let ((no-error t))
(condition-case nil
(progn
;; Potentially error-throwing code here
(error "Potential Error"))
(error (setq no-error nil))) ;; On error, set flag to nil
(if no-error
(message "All good!"))) ;; This runs only if no error was raised
;; Finally, code that runs regardless of error presence
(message "This always runs, simulating 'finally'")
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h3 id="with-statement"&gt;with statement&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Instead of try/finally to cleanup resources you can use a with statement
with open("myfile.txt") as f:
for line in f:
print(line)
# Writing to a file
contents = {"aa": 12, "bb": 21}
with open("myfile1.txt", "w") as file:
file.write(str(contents)) # writes a string to a file
import json
with open("myfile2.txt", "w") as file:
file.write(json.dumps(contents)) # writes an object to a file
# Reading from a file
with open("myfile1.txt") as file:
contents = file.read() # reads a string from a file
print(contents)
# print: {"aa": 12, "bb": 21}
with open("myfile2.txt", "r") as file:
contents = json.load(file) # reads a json object from a file
print(contents)
# print: {"aa": 12, "bb": 21}
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Reading from a file
(with-temp-buffer
(insert-file-contents "myfile.txt")
(goto-char (point-min))
(while (not (eobp))
(message "%s" (buffer-substring (line-beginning-position) (line-end-position)))
(forward-line 1)))
;; Writing to a file
(let ((contents (format "%s" '((aa . 12) (bb . 21)))))
(with-temp-file "myfile1.txt"
(insert contents)))
;; Emacs Lisp doesn't have a built-in JSON parser in its default environment,
;; but assuming json.el or similar is available:
(require 'json)
(let ((contents (json-encode '((aa . 12) (bb . 21)))))
(with-temp-file "myfile2.txt"
(insert contents)))
;; Reading from a file as a string
(let ((contents ""))
(with-temp-buffer
(insert-file-contents "myfile1.txt")
(setq contents (buffer-string)))
(message "Contents of myfile1.txt: %s" contents))
;; Reading from a file as JSON
(let ((contents nil))
(with-temp-buffer
(insert-file-contents "myfile2.txt")
(setq contents (json-read-from-string (buffer-string))))
(message "Contents of myfile2.txt: %s" contents))
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h2 id="functions"&gt;Functions&lt;/h2&gt;
&lt;h3 id="define-a-function"&gt;Define a function&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Use "def" to create new functions
def add(x, y):
print("x is {} and y is {}".format(x, y))
return x + y # Return values with a return statement
# Calling functions with parameters
add(5, 6) # =&gt; prints out "x is 5 and y is 6" and returns 11
# Another way to call functions is with keyword arguments
add(y=6, x=5) # Keyword arguments can arrive in any order.
# You can define functions that take a variable number of
# positional arguments
def varargs(*args):
return args
varargs(1, 2, 3) # =&gt; (1, 2, 3)
# You can define functions that take a variable number of
# keyword arguments, as well
def keyword_args(**kwargs):
return kwargs
# Let's call it to see what happens
keyword_args(big="foot", loch="ness") # =&gt; {"big": "foot", "loch": "ness"}
# You can do both at once, if you like
def all_the_args(*args, **kwargs):
print(args)
print(kwargs)
"""
all_the_args(1, 2, a=3, b=4) prints:
(1, 2)
{"a": 3, "b": 4}
"""
# When calling functions, you can do the opposite of args/kwargs!
# Use * to expand args (tuples) and use ** to expand kwargs (dictionaries).
args = (1, 2, 3, 4)
kwargs = {"a": 3, "b": 4}
all_the_args(*args) # equivalent: all_the_args(1, 2, 3, 4)
all_the_args(**kwargs) # equivalent: all_the_args(a=3, b=4)
all_the_args(*args, **kwargs) # equivalent: all_the_args(1, 2, 3, 4, a=3, b=4)
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Use `defun` to create new functions
(defun add (x y)
(message "x is %d and y is %d" x y)
(+ x y)) ;; Return values with an implicit return (last expression evaluated)
;; Calling functions with parameters
(add 5 6) ;; =&gt; prints out "x is 5 and y is 6" and returns 11
;; Emacs Lisp does not support keyword arguments in the same way Python does,
;; but you can simulate them using a plist (property list).
(defun add-keywords (&amp;rest args)
(let ((x (plist-get args :x))
(y (plist-get args :y)))
(message "x is %d and y is %d" x y)
(+ x y)))
(add-keywords :y 6 :x 5) ;; Keyword arguments can arrive in any order, using plist.
;; You can define functions that take a variable number of
;; positional arguments
(defun varargs (&amp;rest args)
args)
(varargs 1 2 3) ;; =&gt; (1 2 3)
;; You can define functions that take a variable number of
;; keyword arguments, as well
(defun keyword-args (&amp;rest args)
args)
;; Let's call it to see what happens
(keyword-args :big "foot" :loch "ness") ;; =&gt; (:big "foot" :loch "ness")
;; You can do both at once, if you like
(defun all-the-args (&amp;rest args)
(message "args: %s" (prin1-to-string (cl-remove-if (lambda (x) (keywordp x)) args)))
(message "kwargs: %s" (prin1-to-string (cl-loop for (key val) on args by #'cddr collect (cons key val)))))
;; all_the_args(1, 2, a=3, b=4) prints:
;; args: (1 2)
;; kwargs: ((:a . 3) (:b . 4))
;; When calling functions, you can use apply to expand args (lists)
(setq args '(1 2 3 4))
(setq kwargs '(:a 3 :b 4))
(apply 'all-the-args args) ;; equivalent: all_the_args(1, 2, 3, 4)
(apply 'all-the-args (append args kwargs)) ;; equivalent: all_the_args(1, 2, 3, 4, :a 3, :b 4)
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h3 id="global-scopes"&gt;Global scopes&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# global scope
x = 5
def set_x(num):
# local scope begins here
# local var x not the same as global var x
x = num # =&gt; 43
print(x) # =&gt; 43
def set_global_x(num):
# global indicates that particular var lives in the global scope
global x
print(x) # =&gt; 5
x = num # global var x is now set to 6
print(x) # =&gt; 6
set_x(43)
set_global_x(6)
"""
prints:
43
5
6
"""
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Global scope
(defvar x 5)
;; `let` or `let*` is a safe way to get a local scope without altering
;; the global variables directly.
(defun set-x (num)
;; Local scope begins here
(let ((x num)) ;; Local var x, not the same as global var x
(message "%d" x))) ;; =&gt; 43
(defun set-global-x (num)
;; This function uses the global x, if no `let` wrap a local scope
(message "%d" x) ;; =&gt; 5 (initial global value)
(setq x num) ;; Global var x is now set to 6
(message "%d" x)) ;; =&gt; 6
(set-x 43)
(set-global-x 6)
;; This will print:
;; 43
;; 5
;; 6
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h3 id="closures"&gt;Closures&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# Python has first class functions
def create_adder(x):
def adder(y):
return x + y
return adder
add_10 = create_adder(10)
add_10(3) # =&gt; 13
# Closures in nested functions:
# We can use the nonlocal keyword to work with variables in nested scope which shouldn't be declared in the inner functions.
def create_avg():
total = 0
count = 0
def avg(n):
nonlocal total, count
total += n
count += 1
return total/count
return avg
avg = create_avg()
avg(3) # =&gt; 3.0
avg(5) # (3+5)/2 =&gt; 4.0
avg(7) # (8+7)/3 =&gt; 5.0
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Emacs Lisp has first-class functions
(defun create-adder (x)
(lambda (y) (+ x y)))
(setq add-10 (create-adder 10))
(funcall add-10 3) ;; =&gt; 13
;; Closures in nested functions
(defun create-avg ()
(let ((total 0) (count 0))
(lambda (n)
(setq total (+ total n))
(setq count (1+ count))
(/ (float total) count))))
(setq avg (create-avg))
(funcall avg 3) ;; =&gt; 3.0
(funcall avg 5) ;; =&gt; 4.0
(funcall avg 7) ;; =&gt; 5.0
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h3 id="lambda-function"&gt;lambda function&lt;/h3&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# There are also anonymous functions
(lambda x: x &gt; 2)(3) # =&gt; True
(lambda x, y: x ** 2 + y ** 2)(2, 1) # =&gt; 5
# There are built-in higher order functions
list(map(add_10, [1, 2, 3])) # =&gt; [11, 12, 13]
list(map(max, [1, 2, 3], [4, 2, 1])) # =&gt; [4, 2, 3]
list(filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7])) # =&gt; [6, 7]
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; Anonymous functions
(funcall (lambda (x) (&gt; x 2)) 3) ;; =&gt; t (true in Emacs Lisp)
(funcall (lambda (x y) (+ (* x x) (* y y))) 2 1) ;; =&gt; 5
;; First, let's assume 'add-10' is already defined as in the previous example
(setq add-10 (create-adder 10))
;; There are built-in higher order functions
(mapcar add-10 '(1 2 3)) ;; =&gt; (11 12 13)
(mapcar #'max '(1 2 3) '(4 2 1)) ;; =&gt; (4 2 3)
;; Filter using a lambda
(remove-if-not (lambda (x) (&gt; x 5)) '(3 4 5 6 7)) ;; =&gt; (6 7)
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h2 id="modules"&gt;Modules&lt;/h2&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# You can import modules
import math
print(math.sqrt(16)) # =&gt; 4.0
# You can get specific functions from a module
from math import ceil, floor
print(ceil(3.7)) # =&gt; 4
print(floor(3.7)) # =&gt; 3
# You can import all functions from a module.
# Warning: this is not recommended
from math import *
# You can shorten module names
import math as m
math.sqrt(16) == m.sqrt(16) # =&gt; True
# Python modules are just ordinary Python files. You
# can write your own, and import them. The name of the
# module is the same as the name of the file.
# You can find out which functions and attributes
# are defined in a module.
import math
dir(math)
# If you have a Python script named math.py in the same
# folder as your current script, the file math.py will
# be loaded instead of the built-in Python module.
# This happens because the local folder has priority
# over Python's built-in libraries.
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; You can require built-in "modules" (libraries in Emacs terms)
(require 'calc) ;; Emacs's built-in calculator library, similar to importing 'math'
(message "%s" (calc-eval "sqrt(16)")) ;; =&gt; "4.0"
;; In Emacs, you generally use `require` for modules and access functions directly.
;; There isn't a direct equivalent of Python's `from module import specific_function`,
;; but you access everything directly once the library is loaded.
;; Emacs doesn't support `import *` as Python does. Everything is accessible after `require`.
;; You can use `require` with a nickname, but it's less common than in Python.
;; More commonly, Emacs Lisp doesn't rename libraries; it accesses all exported symbols
;; directly after loading them.
;; Loading your own modules is similar to Python:
;; If you write your own Emacs Lisp file, say `my-module.el`, you can load it using:
(load "my-module") ;; Equivalent to Python's import for custom modules.
;; You can list available functions and variables in a library using `C-h f` (for functions)
;; or `C-h v` (for variables) after loading the library, rather than using `dir()` like in Python.
;; Just as with Python, if you have an Emacs Lisp file in your load-path with the same name
;; as a built-in library, it will be loaded instead of the built-in one if you call `load`
;; explicitly with its filename.
;; Here's an example using `cl-lib` which is a common library for utility functions
(require 'cl-lib)
(message "%s" (cl-lib-version)) ;; Access a specific function or variable from `cl-lib`
;; Note: In practice, Emacs Lisp files (.el) when loaded or required, are typically
;; not referred to with an alias like Python's `as` but are loaded and
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h2 id="class"&gt;Class&lt;/h2&gt;
&lt;table&gt; &lt;tr&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="python-html"&gt;
# We use the "class" statement to create a class
class Human:
# A class attribute. It is shared by all instances of this class
species = "H. sapiens"
# Basic initializer, this is called when this class is instantiated.
# Note that the double leading and trailing underscores denote objects
# or attributes that are used by Python but that live in user-controlled
# namespaces. Methods(or objects or attributes) like: __init__, __str__,
# __repr__ etc. are called special methods (or sometimes called dunder
# methods). You should not invent such names on your own.
def __init__(self, name):
# Assign the argument to the instance's name attribute
self.name = name
# Initialize property
self._age = 0 # the leading underscore indicates the "age" property is
# intended to be used internally
# do not rely on this to be enforced: it's a hint to other devs
# An instance method. All methods take "self" as the first argument
def say(self, msg):
print("{name}: {message}".format(name=self.name, message=msg))
# Another instance method
def sing(self):
return "yo... yo... microphone check... one two... one two..."
# A class method is shared among all instances
# They are called with the calling class as the first argument
@classmethod
def get_species(cls):
return cls.species
# A static method is called without a class or instance reference
@staticmethod
def grunt():
return "*grunt*"
# A property is just like a getter.
# It turns the method age() into a read-only attribute of the same name.
# There's no need to write trivial getters and setters in Python, though.
@property
def age(self):
return self._age
# This allows the property to be set
@age.setter
def age(self, age):
self._age = age
# This allows the property to be deleted
@age.deleter
def age(self):
del self._age
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;td&gt; &lt;pre&gt;&lt;code class="lisp-html"&gt;
;; There is no built-in approach to define a struct.
;; The cl-lib extension brings `cl-defstruct` from Common Lisp.
;; Define a struct to mimic a class
(cl-defstruct (human
(:constructor create-human (name)) ;; constructor function
(:conc-name human-)) ;; prefix for automatically generated accessor functions
name ;; This will create human-name accessor
(age 0) ;; Default age, creating human-age accessor and mutator
(species "H. sapiens")) ;; A default class-like attribute, shared unless overridden
;; Instance method equivalent
(defun human-say (this msg)
(message "%s: %s" (human-name this) msg))
(defun human-sing ()
"yo... yo... microphone check... one two... one two...")
;; Class method equivalent
(defun human-get-species (this)
(human-species this))
;; Static method equivalent
(defun human-grunt ()
"*grunt*")
;; Using the struct with methods
(let ((bob (create-human "Bob")))
(human-say bob "Hello!") ;; Bob: Hello!
(message "Bob sings: %s" (human-sing)) ;; Bob sings: yo... yo... microphone check... one two... one two...
(message "Species: %s" (human-get-species bob)) ;; Species: H. sapiens
(setf (human-age bob) 25) ;; Setting age
(message "Bob's age: %d" (human-age bob)) ;; Bob's age: 25
(message "Static call: %s" (human-grunt))) ;; Static call: *grunt*
;; Properties as getters/setters are handled by the `cl-defstruct` accessors and mutators
;; `age` property management is already provided by the struct definition
&lt;/code&gt;&lt;/pre&gt; &lt;/td&gt;
&lt;/tr&gt; &lt;/table&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://learnxinyminutes.com/docs/python/"&gt;Learn Python in Y Minutes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ChatGPT helps to generate most of the code examples&lt;/li&gt;
&lt;/ul&gt;
&lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"&gt;&lt;/script&gt;
&lt;!-- and it's easy to individually load additional languages --&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"&gt;&lt;/script&gt;
&lt;script&gt;hljs.highlightAll();&lt;/script&gt;
&lt;style&gt;
table td {
display: block;
float: left;
width: 50%;
}
&lt;/style&gt;</description></item></channel></rss>